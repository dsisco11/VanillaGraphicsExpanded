Issues:
  ☐ Mod settings not live reloading properly (e.g. changes to Lumon shader settings dont always take effect).
  ☐ Implement blue noise for use in lumon probe jitter, dithering, and PBR material noise.
  ☐ pbr-direct-lighting doesnt include flood-filled block-light.
  ☐ pbr-direct-lighting doesnt include flood-filled sun-light.
  ☐ pbr-direct-lighting doesnt include shadow map.
  
New Features:
  PBR Material Definitions:
    ☐ Asset mapping rules should support specifying compound textures (overlay textures, etc) which use the canonical "++0~" combiner syntax. (eg. "game:block/clay/brick/four/soldier/cream1++0~game:block/clay/brick/four/soldier/black1")
      - Maybe we should just allow overlay assets to specify their material/normal/depth textures which are then combined with the base asset's textures when used as a composite texture?
    ☐ Material atlas population should be an async progressive system.
    ☐ Need a notification-panel-like gui for showing background task progress and errors (eg. material atlas population progress/errors).

LumOn → Lumen Alignment Work (Screen-Space Pipeline):

  Reference:
  - docs/LumOn.08-Pipeline-Alignment-with-Lumen.md (Section 6 target pipeline)

  Dependency order notes:
  - Pass 0 (HZB) modifies the tracer, so if we do it, do it before adding confidence + temporal/filter tuning.
  - Confidence must exist before: temporal-confidence blending, probe-space filtering, and cheaper gather projections.
  - Probe-space filtering must exist before any gather path that assumes "stable" probe radiance.

  Target pipeline:
    0. (New) Depth pyramid / HZB (optional, recommended)
    1. Probe Anchor (with jitter)
    2. Screen-Probe Atlas Trace (radiance + hitdist + meta)
    3. Screen-Probe Atlas Temporal (expanded to use meta)
    3.5 (New) Probe-space filter/denoise (edge-stopped)
    4. Gather (cheaper)
    5. Upsample (optional spatial denoise)
    6. Combine (optional)

✔ Phase 7 - Pass 1 - Probe Anchor Jitter: @done(26-01-17 09:06)
  Exit artifacts: Probe anchor pass supports jitter (frameIndex plumbing + optional config toggles); probe anchors remain MRT posWS/normalWS.

✔ Phase 8 - Pass 0 (Optional/Recommended) - Depth Pyramid / HZB: @done(26-01-17 09:06)
  Exit artifacts: Depth pyramid textures exist per frame; screen-probe tracer can consume HZB for traversal/refinement.

✔ Phase 9.0 - Naming/Refactor - Screen-Probe Atlas Terminology: @done(26-01-17 09:05)
  Exit artifacts: Public-facing names and file/class identifiers use “ScreenProbeAtlas” (or similar) instead of “Octahedral”, while octahedral remains an implementation detail for the mapping math.

✔ Phase 9 - Pass 2 - Screen-Probe Atlas Meta Output: @done(26-01-17 09:05)
  Exit artifacts: Screen-probe trace outputs radiance/hitdist plus meta (confidence + bitflags); history preservation applies to meta too.

✔ Phase 10 - Pass 3 - Screen-Probe Atlas Temporal Uses Meta: @done(26-01-17 09:05)
  Exit artifacts: Screen-probe atlas temporal produces meta-aware stabilized atlases suitable for downstream filtering/gather.

✔ Phase 11 - Pass 3.5 - Probe-Space Filter/Denoise (New): @done(26-01-17 09:03)
  Exit artifacts: Filtered atlas exists (radiance/hitdist/confidence as applicable); renderer can choose raw vs filtered as gather input.

✔ Phase 12 - Pass 4 - Cheaper Gather Options: @done(26-01-17 09:03)
  Exit artifacts: Gather has a defined “cheap” mode (stride/fewer dirs) and/or a projected-basis path (if implemented) selectable via config.

✔ Phase 13 - Integration, Debug, and Performance: @done(26-01-17 09:03)
  Exit artifacts: New passes are debuggable and timed; perf baselines documented; optional minimal visual regression hooks exist.

☐ Phase 14 - Screen-Space Parity/Polish (Remaining Discrepancies):
  Depends on: Phase 9 (confidence), Phase 10 (temporal uses confidence), Phase 11 (probe-space filter).
  Exit artifacts: Screen-space GI is more Lumen-like in stability/robustness (exposure-stable, fewer edge holes, fewer temporal fireflies), with tests/diagnostics.
  ☐ Reprojection inputs (motion vectors / camera motion):
    - Determine whether VS exposes motion vectors or equivalent per-pixel velocity
    - If available: incorporate into temporal rejection/weighting for gather/upsample (and/or probe updates)
    - If not available: implement a best-effort camera-motion heuristic path (rotation/translation gating)
  ☐ Exposure / color space consistency:
    - Verify whether CapturedSceneTex is pre- or post-tonemap (and whether exposure changes frame-to-frame)
        Verified: it is pre-tonemap.
    - Add a debug view to compare captured scene vs expected linear lighting space
  ☐ Variance / moments for temporal stability:
    - Add optional moments buffer (e.g., first/second moment of radiance) for the probe atlas or for indirectHalf
    - Use it for variance clamp/firefly suppression in temporal and/or post-filter
  ☐ Screen-trace hole filling strategy:
    ✔ Add a controlled neighborhood resolve for rays that exit screen / miss due to disocclusion @done
    ✔ Use confidence to avoid smearing across depth/normal edges @done
    ✔ Ensure this is a bounded fallback (never overrides high-confidence hits) @done
  ☐ Sky visibility / sky-occlusion term (screen-space approximation):
    - Add an optional, cheap sky-visibility estimate (screen-space only) to reduce overly bright indoor skylight
    - Keep it explicitly marked as screen-space approximation (no world proxy)
  ☐ Add GPU functional tests:
    - ExposureChange_DoesNotCauseTemporalPumping (or a reduced equivalent)
    - VarianceClamp_ReducesFireflies_PreservesMean
    ✔ HoleFill_OnlyAffectsLowConfidenceAreas @done
    - SkyVisibility_ReducesIndoorSkylightWithoutBlackening

✔ Phase 15 - BRDF + AO + Bent-Normal Compositing (New): @done(26-01-17 09:03)
  Goal: Replace the current “simple add” indirect integration with a physically-plausible compositing pass that
  accounts for roughness/metallic/specular response and supports AO + bent normals for better contact and sky occlusion.

  Exit artifacts: A dedicated composite stage exists (shader + program + renderer wiring) that:
    - Computes indirect diffuse/specular using a BRDF approximation (energy-conserving) from G-buffer material inputs
    - Applies AO and (optionally) bent-normal-based visibility for ambient/sky contribution
    - Produces stable, debuggable outputs with tests for correctness and edge cases

✔ Phase 16 - PBR Direct Lighting Pass System (New): @done(26-01-17 09:03)
  Goal: Create a dedicated, high-quality PBR direct-lighting pass that is independent of LumOn
  (LumOn remains indirect lighting and can be disabled), but produces the “direct” lighting inputs
  that LumOn consumes downstream for final compositing.

  This pass system will supersede the existing pbr-overlay approach.

  Exit artifacts: A direct-lighting pipeline exists that:
    - Produces a stable, linear-space direct lighting buffer (pre-tonemap) suitable for downstream GI
    - Uses physically-based lighting consistent with the BRDF assumptions in Phase 15
    - Can be run with LumOn disabled (direct lighting still correct)
    - Has clear attachment points for LumOn (capture sceneDirect, optional material buffers)
    - Replaces pbr-overlay in both runtime behavior and debug tooling

☐ Phase 17 - Bent Normal Signal Generation (New):
  Goal: Produce a stable, deterministic “bent normal” (or equivalent visibility direction) signal
  that can be fed into Phase 15 compositing, so bent-normal shading is based on real scene occlusion
  rather than a placeholder heuristic.

  Exit artifacts: A bent-normal signal exists per-pixel (and/or per-probe) with:
    - Clear definition of coordinate space (WS vs VS) and encoding
    - Stable output across frames (temporal stabilization as needed)
    - Plumbed into the Phase 15 composite split
    - Debug visualization modes and GPU functional tests

  Work items:
  ☐ Decide bent-normal source + representation:
    - Option A (screen-space): per-pixel bent normal from multi-direction screen-space visibility
      - Sample a small set of directions around the shading normal
      - Accumulate unoccluded directions weighted by cosine/solid-angle to produce bent normal
    - Option B (probe-derived): per-probe bent normal from Screen-Probe Atlas meta/hit distances
      - Estimate dominant visibility direction per probe, then gather/interpolate to pixels
    - Representation:
      - Store bent normal as unit vector (octahedral encoding recommended) + optional cone angle
      - Define fallback behavior when confidence is low (use geometric normal)

  ☐ Add buffer(s) in LumOnBufferManager:
    - Allocate bent normal target(s):
      - Full-res: BentNormalTex (RGBA16F or RG16F oct-encoded)
      - Optional half-res variant if generated alongside indirectHalf
    - If temporal: BentNormalHistoryTex + meta to stabilize across frames

  ☐ Add new shader pass (or extend an existing pass) to generate bent normals:
    - New shader pair suggestion: lumon_bent_normal.vsh / lumon_bent_normal.fsh
    - Inputs:
      - primaryDepth, gBufferNormal
      - (optional) ScreenProbeAtlas radiance/hitdist/meta and/or indirectHalf alpha weight
    - Outputs:
      - bentNormal (encoded)
      - (optional) bentConeAngle or confidence

  ☐ Temporal stabilization (if needed):
    - Reproject previous bent normal using existing matrices
    - Reject history on depth/normal mismatch (reuse thresholds)
    - Clamp/normalize to keep unit length

  ☐ Composite plumbing:
    - Bind bent normal texture into Phase 15 composite path
    - Replace placeholder “bend toward up” heuristic with sampled bent normal
    - Ensure behavior is gated behind EnableBentNormal and falls back cleanly

  ☐ Debug modes + visualization:
    - BentNormalDirection (RGB visualization in view/world space)
    - BentNormalVsGeometricNormal (difference heatmap)
    - BentNormalConfidence / ConeAngle visualization (if implemented)

  ☐ GPU functional tests:
    - BentNormal_UnitLength_OrValidFallback
    - BentNormal_OccluderBendsAwayFromBlockedDirections (minimal deterministic occluder)
    - BentNormal_TemporalStableUnderStaticCamera
    - BentNormal_RejectionOnDisocclusion

☐ Phase 18 - World-Space Clipmap Probe System - Architecture Docs (New):
  Goal: Define and document the initial architecture for a world-space clipmap-based probe system
  (Lumen-like “world probes”) that can coexist with the current screen-space LumOn pipeline and
  eventually feed the same compositing stage.

  Exit artifacts: A set of architecture design documents exists under docs/ that:
    - Clearly defines terms, coordinate spaces, and data layouts
    - Describes update cadence, streaming, and stability rules
    - Specifies GPU/CPU responsibilities and performance constraints
    - Includes diagrams for data flow and clipmap topology

  Work items:
  ☐ Create docs/LumOn.16-World-Space-Clipmap-Probes.md (overview + goals/non-goals):
    - Motivation vs screen-space probes
    - Integration strategy: how world probes feed the same indirectRadiance path
    - Constraints: VS chunking, memory budget, update bandwidth, fallback behavior

  ☐ Create docs/LumOn.17-Clipmap-Topology-and-Addressing.md:
    - Clipmap levels, voxel/probe spacing per level
    - World-to-clipmap addressing (level selection, wrapping, origin snapping)
    - Probe indexing and coordinate transforms (WS ↔ clipmap local)
    - Edge behavior (seams, cross-level blending)

  ☐ Create docs/LumOn.18-Probe-Data-Layout-and-Packing.md:
    - What each probe stores initially (irradiance SH, visibility/cone, hit distance, confidence)
    - Texture formats and packing (SH9 vs SH3, atlas vs 3D textures, oct encoding)
    - Versioning strategy for evolving layouts

  ☐ Create docs/LumOn.19-Update-Pipeline-and-Scheduling.md:
    - Update triggers: camera movement thresholds, time slicing, per-level budgets
    - Probe selection policy (prioritize near field, dirty regions)
    - Temporal stabilization rules (history blending, invalidation)
    - Interaction with dynamic geometry / lighting changes

  ☐ Create docs/LumOn.20-Streaming-and-Persistence.md:
    - CPU-side cache (what persists across sessions, if any)
    - Region eviction and reuse when clipmap origin shifts
    - Determinism requirements (same camera path → stable probe identity)

  ☐ Create docs/LumOn.21-Shading-Integration.md:
    - Sampling world probes at a pixel/point (trilinear, anisotropic, normal-based weighting)
    - Combining with screen-space GI (screen-first fallback, confidence-based blending)
    - Feeding Phase 15 compositing inputs (indirectRadiance + optional bent normal/visibility)

  ☐ Diagrams (Mermaid in each doc as appropriate):
    - System dataflow: CPU scheduling → GPU update passes → shading sample
    - Clipmap level layout and origin snapping
    - Probe update state machine (dirty → tracing → filtered → ready)

  ☐ Open questions section in each doc:
    - SH order choice (L1 vs L2) and memory math
    - Trace source (hardware RT? screen-space? world BVH?) and feasibility in VS context
    - How to represent and use visibility (cone angle vs scalar vs bent normal)
