LumOn GPU Shader Functional Tests:
  Configuration:
    ☐ Probe grid size: 2×2 (4 probes)
    ☐ Octahedral atlas size: 16×16 (8 texels per probe)
    ☐ Screen buffer size: 4×4 pixels
    ☐ Half-res buffer size: 2×2 pixels
    ☐ Test epsilon: 1e-4f for float comparisons

  Phase 1 - Test Infrastructure:
    ✔ Extend DynamicTexture.cs (VanillaGraphicsExpanded/Rendering/) @done
      ✔ Add UploadData(float[] data) method - upload pixel data to existing texture @done
      ✔ Add UploadData(float[] data, int x, int y, int w, int h) - partial upload @done
      ✔ Add ReadPixels() method - readback texture contents as float[] @done
      ✔ Add static CreateWithData(w, h, format, float[] data) factory method @done
    ✔ Create ShaderTestFramework.cs in VanillaGraphicsExpanded.Tests/GPU/Helpers/ @done
      ✔ RenderQuad(programId) - fullscreen triangle to bound GBuffer @done
      ✔ CreateTestGBuffer(width, height, format, attachmentCount) - convenience wrapper around GBuffer.CreateMRT @done
      ✔ Uses DynamicTexture.Bind(unit) for input texture binding @done
      ✔ Uses DynamicTexture.ReadPixels() for output validation @done
      ✔ Uses GBuffer.Bind()/Unbind() for render target management @done
    ✔ Create PixelComparer.cs in VanillaGraphicsExpanded.Tests/GPU/Helpers/ @done
      ✔ AssertPixelsMatch(float[] expected, float[] actual, float epsilon) @done
      ✔ Report first N mismatches with (x, y) coordinates and delta values @done
      ✔ Support per-channel epsilon for HDR tolerance @done
      ✔ Format failure messages with hex color comparison @done
    ✔ Create UniformValidator.cs in VanillaGraphicsExpanded.Tests/GPU/Helpers/ @done
      ✔ ExtractUniforms(string processedSource) using GlslSchema.Instance @done
      ✔ ValidateUniformsSet(uniforms, setUniformNames) - fail if missing @done
      ✔ IsSamplerType(string typeName) - distinguish texture uniforms @done
      ✔ Generate uniform checklist report for test setup verification @done

  Phase 2 - Test Input Factory:
    ✔ Create LumOnTestInputFactory.cs in VanillaGraphicsExpanded.Tests/GPU/Helpers/ @done
      ✔ Depth buffer generators (4×4): @done
        ✔ CreateDepthBufferLinearRamp() - 0.1 to 0.9 gradient @done
        ✔ CreateDepthBufferUniform(float depth) - constant depth @done
        ✔ CreateDepthBufferCheckerboard() - alternating near/far @done
      ✔ Normal buffer generators (4×4): @done
        ✔ CreateNormalBufferUpward() - all (0, 1, 0) @done
        ✔ CreateNormalBufferAxisAligned() - one axis per quadrant @done
        ✔ CreateNormalBufferFromDepth(float[] depth) - derive from depth discontinuities @done
      ✔ Probe anchor generators (2×2): @done
        ✔ CreateProbePositions() - grid at known world coords @done
        ✔ CreateProbeNormals() - uniform upward @done
        ✔ CreateProbeValidity() - all valid (w=1.0) @done
      ✔ Radiance generators: @done
        ✔ CreateRadianceAtlasSolidQuadrants() - RGBW per quadrant (16×16) @done
        ✔ CreateRadianceAtlasGradient() - horizontal gradient (16×16) @done
        ✔ CreateSHCoefficientsUniform(vec3 color) - L1 SH for solid color (2×2) @done
      ✔ Matrix generators: @done
        ✔ CreateIdentityView() - identity 4×4 @done
        ✔ CreateIdentityProjection() - identity 4×4 @done
        ✔ CreateSimplePerspective(fov, aspect, zNear, zFar) @done
        ✔ CreateInverseMatrix(float[] matrix) @done
      ✔ Scene input generators: @done
        ✔ CreateAlbedoBuffer(vec3 color) - uniform albedo (4×4) @done
        ✔ CreateDirectLightingBuffer() - simple lit scene (4×4) @done
        ✔ CreateMaterialBuffer(metallic, roughness) - uniform material (4×4) @done

  Phase 3 - Probe Anchor Tests:
    ✔ Create LumOnProbeAnchorFunctionalTests.cs @done
      ✔ Test: UniformDepth_ProducesCorrectWorldPositions @done
        ✔ Input: depth=0.5 everywhere, identity matrices @done
        ✔ Expected: probes at calculated world Z from linearized depth @done
        ✔ Verify: outPosition.xyz matches hand-calculated values @done
      ✔ Test: UniformDepth_ProducesCorrectNormals @done
        ✔ Input: normals all (0,1,0) in G-buffer @done
        ✔ Expected: outNormal.xyz = (0,1,0) for all probes @done
      ✔ Test: ValidProbes_HaveValidityFlagSet @done
        ✔ Input: valid depth, valid normals @done
        ✔ Expected: outPosition.w = 1.0 for all probes @done
      ✔ Test: SkyPixels_ProduceInvalidProbes @done
        ✔ Input: depth=1.0 (sky/far plane) @done
        ✔ Expected: outPosition.w = 0.0 (invalid) @done
      ✔ Document expected value derivation in comments: @done
        // depth=0.5, zNear=0.1, zFar=100
        // linearDepth = zNear * zFar / (zFar - depth * (zFar - zNear))
        // worldPos = invView * invProj * clipPos

  Phase 4 - Probe Trace Octahedral Tests:
    ✔ Create LumOnProbeTraceOctahedralFunctionalTests.cs @done
      ✔ Test: ValidProbe_TracesRaysToAtlas @done
        ✔ Input: single valid probe, simple scene color @done
        ✔ Expected: 8×8 texel region filled with traced radiance @done
      ✔ Test: SkyMiss_ReturnsAmbientColor @done
        ✔ Input: rays that miss geometry (depth=1.0 everywhere) @done
        ✔ Expected: radiance = ambientColor * skyMissWeight @done
      ✔ Test: HitDistance_EncodedCorrectly @done
        ✔ Input: known geometry at specific distance @done
        ✔ Expected: outRadiance.a = log-encoded hit distance @done
      ✔ Test: InvalidProbe_ProducesZeroRadiance @done
        ✔ Input: probe with validity=0 @done
        ✔ Expected: all 64 texels = (0,0,0,0) @done

  Phase 5 - Temporal Accumulation Tests:
    ✔ Create LumOnTemporalFunctionalTests.cs @done
      ✔ Single-frame tests (α=1.0 bypass): @done
        ✔ Test: AlphaOne_PassthroughCurrent @done
          ✔ Input: current=red, history=blue, temporalAlpha=1.0 @done
          ✔ Expected: output = red (current passthrough) @done
        ✔ Test: AlphaOne_MetaUpdated @done
          ✔ Input: new depth/normal values @done
          ✔ Expected: outMeta contains current frame values @done
      ✔ Two-frame blend tests (α=0.9): @done
        ✔ Test: AlphaBlend_AccumulatesHistory @done
          ✔ Input: current=varied, history=gray, temporalAlpha=0.9 @done
          ✔ Expected: output = blended (accounting for neighborhood clamping) @done
        ✔ Test: DepthRejection_DiscardsHistory @done
          ✔ Input: large depth change between frames @done
          ✔ Expected: output = current (history rejected) @done
        ✔ Test: NormalRejection_DiscardsHistory @done
          ✔ Input: large normal change between frames @done
          ✔ Expected: output = current (history rejected) @done
        ✔ Test: AccumCount_Increments @done
          ✔ Input: valid accumulation @done
          ✔ Expected: outMeta.accumCount = history.accumCount + 1 @done

  Phase 6 - Gather Pass Tests:
    ✔ Create LumOnGatherOctahedralFunctionalTests.cs @done
      ✔ Test: CenterPixel_InterpolatesFourProbes @done
        ✔ Input: 2×2 probes with RGBW radiance @done
        ✔ Expected: center pixel = average of 4 probes @done
      ✔ Test: CornerPixel_WeightedByDistance @done
        ✔ Input: pixel near probe (0,0) @done
        ✔ Expected: heavily weighted toward that probe's radiance @done
      ✔ Test: DepthDiscontinuity_ReducesWeight @done
        ✔ Input: large depth difference between pixel and probe @done
        ✔ Expected: that probe contributes less @done
      ✔ Test: NormalMismatch_ReducesWeight @done
        ✔ Input: pixel normal opposite to probe normal @done
        ✔ Expected: that probe contributes less @done
      ✔ Test: IndirectTint_AppliedToOutput @done
        ✔ Input: indirectTint = (2, 1, 0.5) @done
        ✔ Expected: output.rgb *= indirectTint @done
      ✔ Test: SkyPixels_ProduceZeroIrradiance (bonus test) @done
        ✔ Input: depth=1.0 (sky) @done
        ✔ Expected: output = (0, 0, 0) @done

  Phase 7 - Upsample Pass Tests:
    ☐ Create LumOnUpsampleFunctionalTests.cs
      ☐ Test: UniformInput_BilinearUpsample
        ☐ Input: uniform 2×2 half-res, uniform depth/normal
        ☐ Expected: uniform 4×4 full-res (same color)
      ☐ Test: GradientInput_SmoothUpsample
        ☐ Input: gradient 2×2 half-res
        ☐ Expected: interpolated 4×4 gradient
      ☐ Test: DepthEdge_PreservesSharpness
        ☐ Input: depth discontinuity at edge
        ☐ Expected: bilateral filter respects edge
      ☐ Test: DenoiseDisabled_RawBilinear
        ☐ Input: denoiseEnabled=0
        ☐ Expected: pure bilinear without edge-awareness

  Phase 8 - Combine Pass Tests:
    ☐ Create LumOnCombineFunctionalTests.cs
      ☐ Test: BasicComposite_AddsIndirect
        ☐ Input: direct=(1,0,0), indirect=(0,1,0), albedo=(1,1,1)
        ☐ Expected: output = (1,1,0) (direct + indirect * albedo)
      ☐ Test: AlbedoModulation_AppliedToIndirect
        ☐ Input: indirect=(1,1,1), albedo=(1,0,0)
        ☐ Expected: indirect contribution = (1,0,0)
      ☐ Test: IndirectIntensity_ScalesContribution
        ☐ Input: indirectIntensity=2.0
        ☐ Expected: indirect contribution doubled
      ☐ Test: LumOnDisabled_PassthroughDirect
        ☐ Input: lumOnEnabled=0
        ☐ Expected: output = direct (no indirect added)
      ☐ Test: SkyPixels_NoIndirect
        ☐ Input: depth=1.0 (sky)
        ☐ Expected: output = direct (skip indirect for sky)

  Phase 9 - Integration & CI:
    ☐ Create base class LumOnShaderFunctionalTestBase
      ☐ Common fixture setup (HeadlessGLFixture)
      ☐ Shared helper methods for texture creation
      ☐ Uniform validation integration
      ☐ Cleanup/dispose pattern
    ☐ Add [Trait("Category", "GPU")] to all functional tests
    ☐ Add [SkipOnCI] attribute for tests requiring real GPU
    ☐ Verify Mesa llvmpipe compatibility on GitHub Actions
    ☐ Add GPU test category to CI workflow (optional separate job)
    ☐ Document test data derivation in XML comments

  Future Enhancements (Deferred):
    ☐ Edge case: invalid probes at screen boundaries
    ☐ Edge case: depth discontinuity threshold tuning
    ☐ Edge case: sky pixels mixed with geometry
    ☐ Performance benchmarks with GPU timer queries
    ☐ Visual regression tests with image diff
    ☐ Fuzz testing with randomized inputs
