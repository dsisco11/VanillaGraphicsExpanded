PBR Explicit Texture Overrides (Material Params + Normal/Height):

Goal:
  Implement per-texture mapping-rule overrides in `material_definitions.json` allowing users to provide explicit:
  - Material params map (packed): R=roughness, G=metallic, B=unused(0), A=1
  - Normal+height map (packed): RGB=normal (tangent/object space per existing pipeline), A=height

  Supported file formats:
  - `.png` via VS asset system
  - `.dds` via BCnEncoder.NET decode → RGBA

  Behavior:
  - Overrides referenced via shorthand asset ids (`domain:path`) using `AssetLocation`.
  - If override is present and loads successfully, it is copied into the atlas rect and procedural generation/baking is skipped for that rect.
  - If override is missing/invalid/unloadable, log a warning and fall back to existing procedural generation/bake behavior.

Phase 0 — Design + Contracts:
  ✔ Define override JSON shape under mapping rule `values`:
    - `values.overrides.materialParams` : string (AssetLocation shorthand)
    - `values.overrides.normalHeight`  : string (AssetLocation shorthand)
    - Applies to every texture matched by the rule (for per-texture overrides, write narrower globs / more rules).
    - Example:
      - "values": {
          "material": "stone",
          "overrides": {
            "materialParams": "mymod:textures/vge/params/stone/granite_pbr.png",
            "normalHeight":  "mymod:textures/vge/normalheight/stone/granite_nh.dds"
          }
        }

  ✔ Decide expected normal encoding (confirm matches current normal+height atlas consumer expectations).
    - Encoding matches `assets/vanillagraphicsexpanded/shaders/includes/vge_normaldepth.glsl`:
      - NormalHeight atlas is RGBA16F = (normalXYZ_01, height01)
      - RGB is normal packed to [0,1] (consumer can convert to signed via *2-1)
      - A is height01 in [0,1], where 0.5 ~= 0 signed height
      - A=0 is treated as "no surface" (flat normal and zero depth contribution)
    - Copy/blit path should preserve these semantics; ideally also apply the same alpha-cutoff masking as the procedural pack stage.

  ✔ Define warning format (include rule id, target texture id, override id, failure reason).
    - Use a consistent prefix and include all identifiers:
      - "[VGE] PBR override ignored: rule='{ruleId}' target='{targetTextureId}' override='{overrideId}' reason='{reason}'. Falling back to generated maps."

Phase 1 — Schema + DTOs:
  ✔ Update schema: `schemas/pbr_material_definitions.schema.json`
    - Extend mapping `values` to include optional `overrides` object.
    - Validate strings (non-empty) and allow additional properties only where intentional.
  ✔ Update JSON DTOs: `VanillaGraphicsExpanded/PBR/Materials/PbrMaterialDefinitionsModels.cs`
    - Add `Overrides` object on mapping values model.
    - Add strongly-typed fields for `MaterialParams` and `NormalHeight`.

Phase 2 — Rule Resolution + Normalization:
  ✔ Extend registry output model to carry per-texture override refs alongside chosen material.
    - Implement in `VanillaGraphicsExpanded/PBR/Materials/PbrMaterialRegistry.cs`.
  ✔ Parse shorthand ids using `AssetLocation`:
    - `new AssetLocation(string)` for `values.overrides.*`.
    - Apply default domain if missing.
  ✔ Keep existing mapping precedence semantics:
    - Higher priority wins; on tie, first match wins.
  ✔ Add basic validation for override refs:
    - If invalid AssetLocation parse or unsupported extension → warning + treat as no override.

Phase 3 — Texture Override Loading (PNG + DDS):
  ✔ Add helper: `PbrOverrideTextureLoader` (new file under `VanillaGraphicsExpanded/PBR/Materials/`)
    - Input: `ICoreClientAPI capi`, `AssetLocation overrideId`
    - Output: decoded RGBA pixels + width/height (or upload-ready GPU texture handle)
  ✔ PNG path:
    - Prefer engine/asset APIs to read bytes/stream from assets.
  ✔ DDS path:
    - Use BCnEncoder.NET (`BcDecoder`) to decode DDS to RGBA.
    - Validate DDS format support; warn + fallback if unsupported.
  ✔ Common validation:
    - Enforce expected dimensions (either exact tile size or resample policy).
    - If dimensions mismatch and resample is not implemented, warn + fallback.

Phase 4 — Material Params Atlas Integration:
  ✔ In `VanillaGraphicsExpanded/PBR/Materials/PbrMaterialAtlasTextures.cs`:
    - For each atlas rect, if `materialParams` override loads OK:
      - Copy pixels into the material params atlas rect.
      - Skip procedural fill for that rect.
    - Else:
      - Use existing `PbrMaterialParamsPixelBuilder` procedural generation.
  ✔ Ensure channel packing matches current runtime sampling.

Phase 5 — Normal+Height Atlas Integration (Skip Bake When Overridden):
  ✔ Determine overridden rects before bake:
    - Resolve base texture id → atlas key/rect using `PbrMaterialAtlasPositionResolver`.
  ✔ Build bake job list excluding rects with successfully-loaded `normalHeight` overrides.
    - Implement list filtering in `PbrMaterialAtlasTextures.cs` before calling `PbrNormalDepthAtlasGpuBaker`.
  ✔ After normalDepth atlas clear (and after bake runs for remaining rects), blit/copy overrides into atlas rects.
    - Add a small GPU blit step:
      - Upload override pixels to a temporary GL texture (or reuse cached textures).
      - Draw into atlas with viewport = rect, sampling the override texture.
  ✔ Failure handling:
    - If override load fails, warn and include rect in bake list.

Phase 6 — Caching + Performance:
  ✔ Add per-override texture cache keyed by `AssetLocation` (path equality).
  ✔ Avoid re-decoding DDS every frame (only on initial build / config reload).
  ✔ Ensure temporary GL textures are disposed.

Phase 7 — Tests:
  ✔ Extend mapping tests in `VanillaGraphicsExpanded.Tests/PbrMaterialRegistryPhase8Tests.cs`:
    - Parses override fields.
    - Priority/first-match semantics preserved.
    - Invalid override strings warn + fallback.
  ✔ Add/extend atlas resolver tests in `VanillaGraphicsExpanded.Tests/Unit/PBR/Materials/PbrMaterialAtlasPositionResolverTests.cs`:
    - Shorthand ids normalize deterministically.
  ✔ Add atlas build tests (CPU-side where possible):
    - If material params override present, atlas pixels match override.
    - If override missing, procedural output is used.
  ☐ (Optional GPU test) NormalHeight override rect remains as provided and is not altered by bake.

Phase 8 — Docs + Examples:
  ✔ Document override fields in `README.md` or a new doc under `docs/`.
  ✔ Add example rules in `assets/vanillagraphicsexpanded/config/vge/material_definitions.json`.
  ✔ Add notes on accepted packing + supported DDS types.

Phase 9 — Validation / Acceptance:
  ☐ Manual spot-check:
    - Provide a known `normalHeight.dds` and confirm it appears in the normal/depth atlas.
    - Confirm overridden rects are excluded from procedural bake.
    - Confirm warnings appear and fallback works when override is missing.
  ☐ Run unit tests + any existing build steps.
