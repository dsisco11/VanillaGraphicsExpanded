WorldProbes - Precomputed DiffuseAlbedo + Specular F0 (CPU) + BlockId/Face Reverse Lookup:

  Goal:
  Extend the PBR material registry to precompute per-texture diffuseAlbedo + specular F0 on the CPU,
  then build a reverse lookup keyed by (blockId, face) so the world-probe trace integrator can apply
  per-material factors at trace hits with per-face accuracy.

  Reference:
  - docs/PBRMaterialRegistry.ModderGuide.md (current registry concepts + mapping keys)
  - docs/PBRMaterialDefinitions.schema.md (authoring schema; current stored parameters)
  - docs/MaterialAtlas.Architecture.md (how per-texture sidecar data is built + keyed)
  - docs/MaterialAtlas.BuildPipeline.md (build lifecycle + reload triggers)
  - docs/LumOn.16-World-Space-Clipmap-Probes.md (world probe integration expectations)
  - docs/LumOn.09-PBR-Direct-Lighting-Pass.md (PBR terms + lighting contract)

  Non-goals (this work item):
  - Perfect resolution of composite/overlay textures or alternate variants
  - GPU-side material term packing (this is CPU-only registry data)

  Exit artifacts (overall):
  - Probe hit records include blockId + hit face (as an enum : byte)
  - Material registry stores (roughness/metallic/emissive + diffuseAlbedo + specularF0)
  - A reverse lookup exists: blockId × face -> precomputed (diffuseAlbedo, specularF0)
  - World-probe trace integration applies these factors for hits


  Phase 1 - Data Contracts: Hit Face + BlockId:
  Exit artifacts: Trace hit records carry enough data for O(1) material lookup.
  ✔ Add a new `enum : byte` for probe-hit faces with a stable canonical ordering (±X/±Y/±Z), use the same names and backing numeric values as the base games face enum.
  ✔ Extend the world-probe trace hit struct to include:
    - `int HitBlockId`
    - `ProbeHitFace HitFace`
  ✔ Populate `HitBlockId` during traversal from the traced block (avoid re-querying world in the integrator).
  ✔ Populate `HitFace` deterministically from the axis-aligned hit normal / DDA step.
  ✔ Add TODO: Consider storing additional hit metadata needed for future upgrades (e.g., isLiquid, isTransparent).


  Phase 2 - CPU Precompute: DiffuseAlbedo + Specular F0 Per Texture:
  Exit artifacts: Registry computes and stores derived surface terms per mapped texture key.
  ✔ Decide where derived values live in the registry data model (alongside existing roughness/metallic/emissive).
  ✔ Implement CPU precompute for each mapped base texture (albedoTex):
    - Load bitmap for the base texture asset
    - Compute average baseColor (sRGB) and convert to linear
    - `diffuseAlbedo = baseColorLinear * (1 - metallic)`
    - `specularF0 = lerp(0.04, baseColorLinear, metallic)` (vector3)
  ✔ Define behavior for alpha-cutout textures (e.g., ignore pixels below alpha threshold).
  ✔ Add TODO: Upgrade from simple average to a more robust statistic (median/trimmed mean) to reduce outliers.
  ✔ Add TODO: If/when a dielectric specular/IOR parameter is added, incorporate it into F0 for non-metals.


  Phase 3 - Reverse Lookup: blockId × face -> DerivedSurface:
  Exit artifacts: A fast lookup map exists for the integrator.
  ✔ Choose reverse lookup layout:
    - `DerivedSurface[blockCount][6]` (dense; fastest)
    - or `Dictionary<int, DerivedSurface[6]>` (sparse; lower memory)
  ✔ Build the reverse lookup once the block list + textures are available (and rebuild on texture reload).
  ✔ Resolve each block face to a base texture key that matches registry mapping key-space.
  ✔ Implement a deterministic fallback order per face (face-specific -> all-faces -> first texture).
  ✔ Store a default DerivedSurface for blocks/faces with no resolved mapping.
  ✔ Add TODO: Base-texture resolution only; composites/overlays are not handled yet.
  ✔ Add TODO: Alternate variants selected by RNG/position are not accounted for; consider averaging across variants.


  Phase 4 - Integrator: Apply Factors at Trace Hits:
  Exit artifacts: World-probe integration uses precomputed material terms per hit.
  ✔ Update the world-probe trace integrator to lookup `DerivedSurface` by (HitBlockId, HitFace).
  ✔ Apply `diffuseAlbedo` to hit contribution for diffuse SH accumulation.
  ✔ Thread `specularF0` through hit shading path (even if initially unused) so specular GI can be added later.
  ✔ Add TODO: Define the correct specular-GI path (separate SH vs directional lobe) before consuming specularF0.


  Phase 5 - Debug + Validation:
  Exit artifacts: Easy to verify mapping correctness and catch regressions.
  ☐ Add debug counters/logging (once) for:
    - Missing texture key resolution
    - Blocks/faces falling back to defaults
  ☐ Add a debug view or diagnostic printout that shows (blockId, face) -> resolved texture key -> derived terms.
  ☐ Add a small deterministic test/diagnostic (if a test harness exists) that validates:
    - hit face encoding correctness (normal -> face enum)
    - lookup stability across reload
    - derived values are in sane ranges (diffuseAlbedo in [0,1], F0 in [0,1])
