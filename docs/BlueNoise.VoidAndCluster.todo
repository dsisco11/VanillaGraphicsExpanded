# Blue Noise: Runtime Compute + Cache (Void-and-Cluster)

Goal: Implement a runtime system to compute and cache reusable blue-noise arrays.
Scope: CPU-side generation + cache + configurable outputs. Downstream consumer integration is explicitly out-of-scope.

Key requirements
- Tiling is optional, default `true`.
- Output type is configurable.
- Sizes are configurable.
- Configuration type is a `readonly record struct`.
- Algorithm: Void-and-Cluster (Ulichney).
- Prefer `System.Numerics.Tensors` (`TensorPrimitives`) for bulk operations wherever it makes sense.

---

## Phase 0 — References / Reading
- [x] Confirm exact Void-and-Cluster procedure steps and ranking method (avoid “almost correct” implementations).
  - Practical, concise writeup + discussion: https://momentsingraphics.de/BlueNoise.html
  - Reference implementation (matches Ulichney 1993, includes the 3-phase ranking procedure): https://raw.githubusercontent.com/MomentsInGraphics/BlueNoise/master/BlueNoise.py
  - Original paper (primary source): R. A. Ulichney (1993), “Void-and-cluster method for dither array generation” (Proc. SPIE 1913).
- [x] Identify a concise summary to link in docs (paper, notes, or community writeup).
  - Use https://momentsingraphics.de/BlueNoise.html as the main link; it’s readable and directly covers Void-and-Cluster.
- [x] Review tensor APIs we’ll lean on:
  - https://learn.microsoft.com/dotnet/api/system.numerics.tensors
  - https://learn.microsoft.com/dotnet/api/system.numerics.tensors.tensorprimitives

---

## Phase 1 — Public API + Configuration
- [x] Add `readonly record struct BlueNoiseConfig` (Noise namespace).
  - [x] Fields: `Width`, `Height` (and optional `Depth/Slices` if needed later).
  - [x] `Tileable` default `true`.
  - [x] `Seed` (uint) and `Algorithm` (enum or type tag).
  - [x] Output selection: `BlueNoiseOutputKind` (enum).
  - [x] Algorithm parameters: `Sigma`, `InitialFillRatio`, `MaxIterations`, `StagnationLimit`.
- [x] Add validation helper (throws or returns error result): sizes > 0, sigma > 0, fill in (0,1), etc.
- [x] Define the canonical artifact to cache:
  - [x] Ranked threshold map (e.g., `ushort[]` length = width*height) should likely be the “source of truth”.

---

## Phase 2 — Cache Design (CPU)
- [x] Add `BlueNoiseKey` as a `readonly record struct` suitable as a dictionary key.
  - [x] Include: size, tileable, seed, algorithm id, sigma (cache ranked only; output kind conversion will be on-demand).
- [x] Implement `BlueNoiseCache` (thread-safe) with “create once” semantics.
  - [x] Prefer `ConcurrentDictionary<BlueNoiseKey, Lazy<T>>` or a small `lock`-protected dictionary.
  - [x] Ensure generation work is not done under a long-held lock.
- [x] Decide eviction strategy:
  - [x] Default: no eviction (expect a small fixed set of configs).
  - [x] Optional: bounded LRU for unusual/experimental configs.

---

## Phase 3 — Core Void-and-Cluster Implementation
- [x] Implement `VoidAndClusterGenerator` producing a ranked threshold map.
  - [x] Deterministic RNG: seed with existing stable hashing + Squirrel3-style hash PRNG.
  - [x] Initial binary pattern generation at `InitialFillRatio`.
  - [x] Compute “density” field via Gaussian blur of the binary pattern.
  - [x] Iteratively swap the most “clustered” ON pixel with the most “void” OFF pixel.
    - [x] Define convergence criteria (iteration cap + stagnation).
    - [x] Ensure toroidal addressing when tileable.
  - [x] Ranking step (generate dither matrix thresholds):
    - [x] Confirm Ulichney’s ranking method precisely.
    - [x] Produce ranks `0..(N-1)` (or inverse) consistent with output conversions.
- [x] Boundary behavior:
  - [x] Tileable: toroidal wrap in both axes for all neighborhood/blur ops.
  - [x] Non-tileable: clamp edges consistently.

---

## Phase 4 — Gaussian Blur (Separable) + Tensor Usage
- [x] Build a separable Gaussian kernel from `Sigma`.
  - [x] Choose radius rule (e.g., 3*sigma) and ensure odd kernel length.
  - [x] Normalize kernel sum to 1.
- [x] Implement separable convolution:
  - [x] Horizontal pass into scratch buffer.
  - [x] Vertical pass into output buffer.
- [x] Apply `TensorPrimitives` where it helps:
  - [x] Use `TensorPrimitives.Dot` for inner products in the sliding window implementation.
- [x] Add scratch buffer reuse:
  - [x] Use `ArrayPool<float>` and `ArrayPool<int>` for convolution scratch/indices.

---

## Phase 5 — Output Kinds + Conversions
- [x] Define `BlueNoiseOutputKind` (examples):
  - [x] `RankU16` (canonical / cacheable).
  - [x] `RankU32` (only if required).
  - [x] `NormalizedF32` in [0,1].
  - [x] `L8` byte in [0,255].
  - [x] `BinaryMask` given a threshold or fill ratio.
- [x] Implement conversion pipeline from ranked map to requested output:
  - [x] Use `TensorPrimitives` conversions and math (`ConvertTruncating`, `Multiply`, `Add`, `Clamp`).
  - [x] Validate monotonic mapping and range correctness (range clamps + argument validation).

---

## Phase 6 — Determinism + Correctness Tests
- [x] Add unit tests (no visual output required):
  - [x] Deterministic: same config produces identical results.
  - [x] Different seed differs.
  - [x] Tileable: edge continuity checks (wrap neighborhood / periodic boundary).
  - [x] Output correctness: range checks, size checks, no NaNs.
  - [x] Cache behavior: repeated requests reuse cached artifact.

---

## Phase 7 — PMJ (Temporal Jitter) References + Requirements
- [x] Add primary references for PMJ sampling (for implementation + validation):
  - [x] Kensler (2013): “Correlated Multi-Jittered Sampling” (CMJ background)
    - https://graphics.pixar.com/library/CorrelatedMultiJitteredSampling/
  - [x] Progressive Multi-Jittered (PMJ) / PMJ02 discussion + code references
    - https://graphics.pixar.com/library/ProgressiveMultiJitteredSampling/
    - https://github.com/pixar/RenderManForBlender/blob/master/rman_operators/rman_operators_sampling.py (PMJ-style sequence generation reference)
  - [x] Clarify whether we want PMJ(0,2) specifically (common for temporal jitter).
    - Decision: implement PMJ(0,2) (“PMJ02”) first.
- [x] Define target use-case:
  - [x] Temporal jitter sequence: per-frame 2D offsets in [0,1)^2 and optionally centered [-0.5,0.5).
  - [x] Deterministic per seed + frame index.
  - [x] Optional: per-pixel or per-tile scrambling (seed + salt) to avoid visible correlation.
- [x] Decide canonical artifact:
  - [x] Canonical cache output: sequence of points as `Vector2[]` in [0,1)^2.
  - [x] Conversions: packed `ushort` (RG16_UNorm) and/or `byte` (RG8_UNorm) for texture upload.
  - [x] Optional later: pre-baked “texture tiles” (NxN texels, each texel stores a point for frame f).

---

## Phase 8 — PMJ Public API + Configuration
- [x] Add `readonly record struct PmjConfig` (Noise namespace).
  - [x] Fields: `SampleCount`, `Seed`, `Variant` (enum: PMJ02).
  - [x] Output selection: `PmjOutputKind` (enum).
  - [x] Optional: `OwenScramble` toggle + `Salt`.
  - [x] Optional: `Centered` (map [0,1) → [-0.5,0.5)).
- [x] Add validation helper.
- [x] Define `PmjSequence` artifact type (canonical cache result).

---

## Phase 9 — PMJ Core Implementation
- [ ] Implement `PmjGenerator`.
  - [ ] Start with PMJ(0,2) / “PMJ02” generation.
  - [ ] Deterministic RNG using existing `Squirrel3Noise` hashing.
  - [ ] Ensure progressive property: first N samples form good stratified distributions for many N.
  - [ ] Add optional Owen scrambling (or a cheaper hash-based scramble) without breaking stratification.
- [ ] Add helpers:
  - [ ] `RadicalInverse` / bit-reversal utilities if needed.
  - [ ] Permutation utilities (per stratum) driven by seed.

---

## Phase 10 — PMJ Output Kinds + Texture Packing
- [ ] Define `PmjOutputKind` (examples):
  - [ ] `Vector2F32` points in [0,1).
  - [ ] `Vector2F32Centered` points in [-0.5,0.5).
  - [ ] `RG16_UNorm` packed (u,v) as `ushort` in [0,65535].
  - [ ] `RG8_UNorm` packed (lower precision).
- [ ] Implement conversion pipeline for PMJ sequences:
  - [ ] Prefer `TensorPrimitives` for bulk scale/offset/clamp/convert.
- [ ] Add “temporal jitter texture” layout helpers (CPU-side only):
  - [ ] Option A: 1D texture (width = sampleCount, height = 1).
  - [ ] Option B: 2D atlas (width*height = sampleCount, row-major).
  - [ ] Option C: tiled (repeatable) texture for fixed frame cycles.

---

## Phase 11 — PMJ Cache + Correctness Tests
- [ ] Add `PmjKey` (`readonly record struct`) for caching.
- [ ] Implement `PmjCache` with create-once semantics.
- [ ] Add unit tests:
  - [ ] Deterministic per config.
  - [ ] Different seed differs.
  - [ ] Range checks: all points finite and inside expected bounds.
  - [ ] Basic stratification sanity for early prefixes (e.g., 4/16/64 bins hit counts within tolerance).
  - [ ] Cache reuse behavior.

---

## Phase 12 — PMJ Performance Validation
- [ ] Measure generation time for common sample counts (64/128/256/1024).
- [ ] Confirm minimal allocations (pool usage effective).
- [ ] Decide on recommended defaults (frame cycle length, packing format).

---

## Phase 13 — PMJ Documentation
- [ ] Document:
  - [ ] What PMJ sequences are used for (temporal jitter).
  - [ ] How to interpret outputs (centered vs non-centered).
  - [ ] Recommended cycle lengths and packing formats.
  - [ ] Scrambling options (tradeoffs: decorrelation vs reproducibility).
