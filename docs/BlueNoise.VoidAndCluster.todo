# Blue Noise: Runtime Compute + Cache (Void-and-Cluster)

Goal: Implement a runtime system to compute and cache reusable blue-noise arrays.
Scope: CPU-side generation + cache + configurable outputs. Downstream consumer integration is explicitly out-of-scope.

Key requirements
- Tiling is optional, default `true`.
- Output type is configurable.
- Sizes are configurable.
- Configuration type is a `readonly record struct`.
- Algorithm: Void-and-Cluster (Ulichney).
- Prefer `System.Numerics.Tensors` (`TensorPrimitives`) for bulk operations wherever it makes sense.

---

## Phase 0 — References / Reading
- [x] Confirm exact Void-and-Cluster procedure steps and ranking method (avoid “almost correct” implementations).
  - Practical, concise writeup + discussion: https://momentsingraphics.de/BlueNoise.html
  - Reference implementation (matches Ulichney 1993, includes the 3-phase ranking procedure): https://raw.githubusercontent.com/MomentsInGraphics/BlueNoise/master/BlueNoise.py
  - Original paper (primary source): R. A. Ulichney (1993), “Void-and-cluster method for dither array generation” (Proc. SPIE 1913).
- [x] Identify a concise summary to link in docs (paper, notes, or community writeup).
  - Use https://momentsingraphics.de/BlueNoise.html as the main link; it’s readable and directly covers Void-and-Cluster.
- [x] Review tensor APIs we’ll lean on:
  - https://learn.microsoft.com/dotnet/api/system.numerics.tensors
  - https://learn.microsoft.com/dotnet/api/system.numerics.tensors.tensorprimitives

---

## Phase 1 — Public API + Configuration
- [x] Add `readonly record struct BlueNoiseConfig` (Noise namespace).
  - [x] Fields: `Width`, `Height` (and optional `Depth/Slices` if needed later).
  - [x] `Tileable` default `true`.
  - [x] `Seed` (uint) and `Algorithm` (enum or type tag).
  - [x] Output selection: `BlueNoiseOutputKind` (enum).
  - [x] Algorithm parameters: `Sigma`, `InitialFillRatio`, `MaxIterations`, `StagnationLimit`.
- [x] Add validation helper (throws or returns error result): sizes > 0, sigma > 0, fill in (0,1), etc.
- [x] Define the canonical artifact to cache:
  - [x] Ranked threshold map (e.g., `ushort[]` length = width*height) should likely be the “source of truth”.

---

## Phase 2 — Cache Design (CPU)
- [x] Add `BlueNoiseKey` as a `readonly record struct` suitable as a dictionary key.
  - [x] Include: size, tileable, seed, algorithm id, sigma (cache ranked only; output kind conversion will be on-demand).
- [x] Implement `BlueNoiseCache` (thread-safe) with “create once” semantics.
  - [x] Prefer `ConcurrentDictionary<BlueNoiseKey, Lazy<T>>` or a small `lock`-protected dictionary.
  - [x] Ensure generation work is not done under a long-held lock.
- [x] Decide eviction strategy:
  - [x] Default: no eviction (expect a small fixed set of configs).
  - [x] Optional: bounded LRU for unusual/experimental configs.

---

## Phase 3 — Core Void-and-Cluster Implementation
- [x] Implement `VoidAndClusterGenerator` producing a ranked threshold map.
  - [x] Deterministic RNG: seed with existing stable hashing + Squirrel3-style hash PRNG.
  - [x] Initial binary pattern generation at `InitialFillRatio`.
  - [x] Compute “density” field via Gaussian blur of the binary pattern.
  - [x] Iteratively swap the most “clustered” ON pixel with the most “void” OFF pixel.
    - [x] Define convergence criteria (iteration cap + stagnation).
    - [x] Ensure toroidal addressing when tileable.
  - [x] Ranking step (generate dither matrix thresholds):
    - [x] Confirm Ulichney’s ranking method precisely.
    - [x] Produce ranks `0..(N-1)` (or inverse) consistent with output conversions.
- [x] Boundary behavior:
  - [x] Tileable: toroidal wrap in both axes for all neighborhood/blur ops.
  - [x] Non-tileable: clamp edges consistently.

---

## Phase 4 — Gaussian Blur (Separable) + Tensor Usage
- [x] Build a separable Gaussian kernel from `Sigma`.
  - [x] Choose radius rule (e.g., 3*sigma) and ensure odd kernel length.
  - [x] Normalize kernel sum to 1.
- [x] Implement separable convolution:
  - [x] Horizontal pass into scratch buffer.
  - [x] Vertical pass into output buffer.
- [x] Apply `TensorPrimitives` where it helps:
  - [x] Use `TensorPrimitives.Dot` for inner products in the sliding window implementation.
- [x] Add scratch buffer reuse:
  - [x] Use `ArrayPool<float>` and `ArrayPool<int>` for convolution scratch/indices.

---

## Phase 5 — Output Kinds + Conversions
- [x] Define `BlueNoiseOutputKind` (examples):
  - [x] `RankU16` (canonical / cacheable).
  - [x] `RankU32` (only if required).
  - [x] `NormalizedF32` in [0,1].
  - [x] `L8` byte in [0,255].
  - [x] `BinaryMask` given a threshold or fill ratio.
- [x] Implement conversion pipeline from ranked map to requested output:
  - [x] Use `TensorPrimitives` conversions and math (`ConvertTruncating`, `Multiply`, `Add`, `Clamp`).
  - [x] Validate monotonic mapping and range correctness (range clamps + argument validation).

---

## Phase 6 — Determinism + Correctness Tests
- [x] Add unit tests (no visual output required):
  - [x] Deterministic: same config produces identical results.
  - [x] Different seed differs.
  - [x] Tileable: edge continuity checks (wrap neighborhood / periodic boundary).
  - [x] Output correctness: range checks, size checks, no NaNs.
  - [x] Cache behavior: repeated requests reuse cached artifact.

---

## Phase 7 — PMJ (Temporal Jitter) References + Requirements
- [x] Add primary references for PMJ sampling (for implementation + validation):
  - [x] Kensler (2013): “Correlated Multi-Jittered Sampling” (CMJ background)
    - https://graphics.pixar.com/library/CorrelatedMultiJitteredSampling/
  - [x] Progressive Multi-Jittered (PMJ) / PMJ02 discussion + code references
    - https://graphics.pixar.com/library/ProgressiveMultiJitteredSampling/
    - https://github.com/pixar/RenderManForBlender/blob/master/rman_operators/rman_operators_sampling.py (PMJ-style sequence generation reference)
  - [x] Clarify whether we want PMJ(0,2) specifically (common for temporal jitter).
    - Decision: implement PMJ(0,2) (“PMJ02”) first.
- [x] Define target use-case:
  - [x] Temporal jitter sequence: per-frame 2D offsets in [0,1)^2 and optionally centered [-0.5,0.5).
  - [x] Deterministic per seed + frame index.
  - [x] Optional: per-pixel or per-tile scrambling (seed + salt) to avoid visible correlation.
- [x] Decide canonical artifact:
  - [x] Canonical cache output: sequence of points as `Vector2[]` in [0,1)^2.
  - [x] Conversions: packed `ushort` (RG16_UNorm) and/or `byte` (RG8_UNorm) for texture upload.
  - [x] Optional later: pre-baked “texture tiles” (NxN texels, each texel stores a point for frame f).

---

## Phase 8 — PMJ Public API + Configuration
- [x] Add `readonly record struct PmjConfig` (Noise namespace).
  - [x] Fields: `SampleCount`, `Seed`, `Variant` (enum: PMJ02).
  - [x] Output selection: `PmjOutputKind` (enum).
  - [x] Optional: `OwenScramble` toggle + `Salt`.
  - [x] Optional: `Centered` (map [0,1) → [-0.5,0.5)).
- [x] Add validation helper.
- [x] Define `PmjSequence` artifact type (canonical cache result).

---

## Phase 9 — PMJ Core Implementation
- [x] Implement `PmjGenerator`.
  - [x] Start with PMJ(0,2) / “PMJ02” generation.
  - [x] Deterministic RNG using existing `Squirrel3Noise` hashing.
  - [x] Ensure progressive property: first N samples form good stratified distributions for many N.
  - [x] Add optional Owen scrambling (Owen-style hierarchical bit scrambling) driven by seed + salt.
- [x] Add helpers:
  - [x] Bit-reversal utilities (van der Corput base-2).
  - [x] Sobol(0,2) direction-number helper for the 2nd dimension.

---

## Phase 10 — PMJ Output Kinds + Texture Packing
- [x] Define `PmjOutputKind` (examples):
  - [x] `Vector2F32` points in [0,1).
  - [x] `Vector2F32Centered` points in [-0.5,0.5).
  - [x] `RG16_UNorm` packed (u,v) as `ushort` in [0,65535].
  - [x] `RG8_UNorm` packed (lower precision).
- [x] Implement conversion pipeline for PMJ sequences:
  - [x] Prefer `TensorPrimitives` for bulk scale/offset/clamp/convert.
- [x] Add “temporal jitter texture” layout helpers (CPU-side only):
  - [x] Option A: 1D texture (width = sampleCount, height = 1).
  - [x] Option B: 2D atlas (width*height = sampleCount, row-major).
  - [x] Option C: tiled (repeatable) texture for fixed frame cycles.

---

## Phase 11 — PMJ Cache + Correctness Tests
- [x] Add `PmjKey` (`readonly record struct`) for caching.
- [x] Implement `PmjCache` with create-once semantics.
- [x] Add unit tests:
  - [x] Deterministic per config.
  - [x] Different seed differs.
  - [x] Range checks: all points finite and inside expected bounds.
  - [x] Basic stratification sanity for early prefixes (e.g., 4/16/64 bins hit counts within tolerance).
  - [x] Cache reuse behavior.

---

## Phase 12 — Integrate Blue-Noise Into PBR Material Atlas Baking (Replace Squirrel3)
- [x] Identify where material-param “value noise” is mixed during baking:
  - [x] Locate the bake path(s) that currently call `Squirrel3Noise` to perturb/mix material parameter values.
  - [x] Identify required range/distribution (e.g., [-1,1] vs [0,1]) and how it is applied.
  - [x] Identify coordinate inputs used (texel coords, atlas UVs, material id, etc.).
- [x] Decide replacement strategy:
  - [x] Replace the Squirrel3-hash noise source with a tileable blue-noise sample from a generated rank/normalized map.
  - [x] Choose default config (suggest: tileable 128x128 or 256x256, sigma tuned to prior look).
  - [x] Define mapping from bake texel position → blue-noise lookup (wrap/tile), plus optional per-material salt/offset.
- [x] Implement bake-time sampling:
  - [x] Use `BlueNoiseCache` to generate the canonical rank map once per config.
  - [x] Convert to an efficient CPU-side representation for sampling (e.g., `byte[]` L8 or `float[]` normalized).
  - [x] Replace the Squirrel3 noise callsite(s) in the bake mixer with blue-noise sampling.
  - [x] Ensure deterministic results (seed + stable per-material salt if used).

---

## Phase 13 — Integrate PMJ Temporal Jitter Into LumOn Sampler Shaders
- [x] Identify integration point(s) in LumOn:
  - [x] Find the jitter/blue-noise/random sampling sites in LumOn shader(s) and any existing frame-index inputs.
  - [x] Confirm whether jitter is applied in clip/NDC space, UV space, or ray direction space.
- [x] Decide PMJ binding model:
  - [x] Option A: Upload a 1D PMJ “sequence texture” (width = sampleCount) and index by frame.
  - [x] Option B: Push a small constant buffer of `Vector2` jitter offsets (if the engine path supports it).
  - [x] Default: texture (stable, simple binding, matches existing texture-driven sampling patterns).
- [x] Implement runtime provisioning:
  - [x] Use `PmjCache` to create `PmjSequence` once per config.
  - [x] Pack to `RG16_UNorm` (preferred) or `RG8_UNorm` (fallback) using `PmjConversions`.
  - [x] Upload to a GPU texture and bind it for LumOn passes.
  - [x] Add uniforms: `frameIndex`, `pmjCycleLength`, and optional `pmjSalt`.
- [x] Implement shader-side sampling:
  - [x] Compute `frameIndexMod = frameIndex % pmjCycleLength` (or use helper logic).
  - [x] Fetch jitter offset from PMJ texture; optionally center to [-0.5, 0.5).
  - [x] Apply jitter at the intended stage (sampling kernel / ray gen / reprojection, depending on existing pipeline).
- [ ] Optional decorrelation:
  - [ ] If needed, incorporate per-pixel salt (hash of pixel coords) to decorrelate spatial patterns.

---

## Phase 14 — Integration Validation (Visual + Automated)
- [x] Add/extend unit/integration tests where feasible:
  - [x] PBR bake: determinism + range checks for the new blue-noise mixing path.
  - [x] LumOn: texture upload format/size correctness (no crashes, expected dimensions).
  - [x] LumOn: determinism of generated PMJ textures given fixed seeds.

---

## Phase 15 — Integration Performance + Defaults
- [ ] Measure:
  - [ ] Blue-noise generation + sampling cost during PBR atlas baking.
  - [ ] PMJ upload cost and memory footprint for chosen cycle length + format.
- [ ] Choose recommended defaults:
  - [ ] Blue-noise tile size + sigma (for PBR bake mixing).
  - [ ] PMJ cycle length (e.g., 64/128/256) and packing format (RG16_UNorm preferred).
- [ ] Ensure minimal allocations:
  - [ ] Confirm conversion + packing uses pooling effectively.

---

## Phase 16 — Integration Documentation
- [x] Document:
  - [x] PBR atlas bake: why blue-noise, chosen tile size/sigma, mapping strategy, and how to toggle.
  - [x] LumOn: how PMJ jitter is applied, how cycle length affects stability, and how to debug.
