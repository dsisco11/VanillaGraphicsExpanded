PBR Override Scaling Multipliers (Per-Rule / Per-Override-Texture)

Goal
- Add optional scaling multiplier properties per asset-mapping rule (override texture mapping).
- Semantics: multiply + clamp to [0,1].
- Default behavior: if a value is not specified, it is a no-op (equivalent to scale=1).
- Apply scalers on float RGBA01 data (after decode/normalize), before packing into atlas buffers.
- No new per-frame allocations introduced; reuse existing row/rect loops and pooled buffers.

Non-Goals
- Do not change shader packing conventions (must continue to match existing GLSL expectations).
- Do not change rule matching semantics (priority/regex/glob selection stays the same).

References
- Rule JSON + schema:
  - VanillaGraphicsExpanded/assets/vanillagraphicsexpanded/config/vge/material_definitions.json
  - schemas/pbr_material_definitions.schema.json
- Rule parsing/registry:
  - VanillaGraphicsExpanded/PBR/Materials/PbrMaterialRegistry.cs
  - VanillaGraphicsExpanded/PBR/Materials/PbrMaterialDefinitionsModels.cs
  - VanillaGraphicsExpanded/PBR/Materials/PbrMaterialTextureOverrides.cs
- Override loading (byte RGBA + float RGBA01):
  - VanillaGraphicsExpanded/PBR/Materials/PbrOverrideTextureLoader.cs
- Override application (atlas packing):
  - VanillaGraphicsExpanded/PBR/Materials/PbrMaterialAtlasTextures.cs
  - VanillaGraphicsExpanded/PBR/Materials/PbrMaterialParamsOverrideApplier.cs
- Shader packing expectations:
  - VanillaGraphicsExpanded/assets/vanillagraphicsexpanded/shaders/includes/vge_material.glsl
  - VanillaGraphicsExpanded/assets/vanillagraphicsexpanded/shaders/includes/vge_normaldepth.glsl


Phase 0 — Design + Naming
Exit artifacts: multiplier fields are specified, backward compatible, and unambiguous.
[x] Decide JSON key naming and structure:
    [x] Use camelCase (matches existing overrides keys: materialParams, normalHeight).
        [x] Add optional unified scale object under overrides:
                - scale: { roughness, metallic, emissive, normal, depth }
      Notes:
                - scale.roughness/metallic/emissive apply to materialParams RGB channels.
                - scale.normal is a scalar applied to all RGB normal channels.
                - scale.depth applies to alpha.
[x] Decide clamping policy details:
    [x] Multiply then clamp to [0,1] per output channel.
    [x] Preserve NaN behavior (NaN stays NaN through multiply+clamp).
[x] Decide validation policy for scale values:
    [x] Null/missing => 1.0f (no-op).
    [x] Invalid (NaN/Infinity/negative) => warn once per rule and treat as 1.0f.
    [x] Allow values > 1.0f (boost) and 0..1 (attenuate).


Phase 1 — Schema + Config Docs
Exit artifacts: users can author the new fields correctly.
[x] Update schemas/pbr_material_definitions.schema.json:
    [x] Add new optional field under override entries (scale)
    [x] Add descriptions stating multiply+clamp semantics and defaults
[x] Update VanillaGraphicsExpanded/assets/vanillagraphicsexpanded/config/vge/material_definitions.json:
    [x] Add one example rule demonstrating material param scaling
    [x] Add one example rule demonstrating normal/depth scaling
    [x] Confirm examples remain valid under the updated schema


Phase 2 — Model Types (JSON + Runtime)
Exit artifacts: new fields exist end-to-end from JSON to resolved per-texture overrides.
[x] Update JSON model(s) in VanillaGraphicsExpanded/PBR/Materials/PbrMaterialDefinitionsModels.cs:
    [x] Add optional overrides.scale fields on the override descriptors (per override texture)
[x] Update resolved override type(s) in VanillaGraphicsExpanded/PBR/Materials/PbrMaterialTextureOverrides.cs:
    [x] Store resolved scale values (defaulted to identity)
[x] Update registry plumbing in VanillaGraphicsExpanded/PBR/Materials/PbrMaterialRegistry.cs:
    [x] Parse/validate the new scale fields
    [x] Apply default = 1.0 when missing
    [x] Ensure per-texture resolved overrides carry the scales to the appliers


Phase 3 — Apply Scaling: Material Params Overrides
Exit artifacts: material params overrides honor scales without changing atlas addressing.
[x] Update VanillaGraphicsExpanded/PBR/Materials/PbrMaterialAtlasTextures.cs:
    [x] When loading overrides.MaterialParams via TryLoadRgbaFloats01, also fetch per-rule scales
    [x] Apply multiply+clamp to channels:
        [x] overrides.scale.roughness -> R
        [x] overrides.scale.metallic  -> G
        [x] overrides.scale.emissive  -> B
        [x] (ignore alpha)
    [x] Ensure clamping happens before PbrMaterialParamsOverrideApplier.ApplyRgbOverride
[x] Keep implementation allocation-free:
    [x] Apply scaling during copy/pack (does not mutate cached override float arrays)


Phase 4 — Apply Scaling: Normal/Depth Overrides
Exit artifacts: normalHeight overrides honor scales without changing bake/rect selection.
[x] Update VanillaGraphicsExpanded/PBR/Materials/PbrMaterialAtlasTextures.cs:
    [x] When loading overrides.NormalHeight via TryLoadRgbaFloats01, also fetch per-rule scales
    [x] Apply multiply+clamp to channels:
        [x] overrides.scale.normal -> R,G,B
        [x] overrides.scale.depth  -> A
    [x] Apply scaling before storing into overrideRects and before applying to atlas
[x] Confirm shader expectations remain correct:
    [x] vge_normaldepth.glsl still interprets channels as before


Phase 5 — Tests
Exit artifacts: confidence that default behavior is unchanged and scaling works.
[ ] Add/extend unit tests (VanillaGraphicsExpanded.Tests):
    [ ] Missing fields => no-op (exactly matches current behavior)
    [ ] MaterialParams scaling multiplies and clamps (0..1)
    [ ] NormalHeight scaling multiplies and clamps (0..1)
    [ ] NaN/Infinity handling matches chosen policy
[ ] Run: dotnet test VanillaGraphicsExpanded.Tests/VanillaGraphicsExpanded.Tests.csproj


Phase 6 — Performance Notes (Optional)
Exit artifacts: no perf regressions in hot paths.
[ ] If needed, add a small micro-benchmark harness:
    [ ] Compare pre-scaling vs scaling on representative rect sizes
    [ ] Verify no new per-frame allocations (use profiler/GC stats)


Acceptance Criteria
- Existing material_definitions.json without scale fields behaves identically.
- New optional scale fields are honored per-rule (per override texture mapping).
- Scaling is multiply+clamp to [0,1] per channel.
- No new per-frame allocations are introduced in atlas build paths.
