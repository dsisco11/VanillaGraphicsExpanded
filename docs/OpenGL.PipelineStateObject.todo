```todo
OpenGL PipelineStateObject (PSO) Wrapper (VGE)

Goal:
  Provide a D3D12/Vulkan-style “PSO” experience for OpenGL by bundling a pass/material’s fixed-function state + key bindings
  into an immutable descriptor, and applying it through a state cache with minimal redundant GL calls.

Notes:
  - In OpenGL this is an emulation: GL has a global implicit state machine.
  - The PSO should support 3-way intent per state knob:
      (A) Force default baseline
      (B) Force a specific non-default value
      (C) Don’t care / leave unchanged (use sparingly)
  - Represent intent via two bitsets:
      - defaultMask: which states must be at the baseline default
      - nonDefaultMask: which states must be set to a non-default value stored in the PSO
      (Invariant: defaultMask & nonDefaultMask == 0)

Reference code paths to keep parity with:
  - LumOn debug overlay save/restore: VanillaGraphicsExpanded/VanillaGraphicsExpanded/LumOn/LumOnDebugRenderer.cs
  - “Known-good GL state” offscreen bake: VanillaGraphicsExpanded/VanillaGraphicsExpanded/PBR/Materials/MaterialAtlasNormalDepthGpuBuilder.cs
  - MRT blend func per attachment + re-apply after stomps: VanillaGraphicsExpanded/VanillaGraphicsExpanded/GBuffer/GBufferManager.cs

Docs:
  - OpenGL Wiki (blending): https://www.khronos.org/opengl/wiki/Blending
  - OpenGL Wiki (testing & depth): https://www.khronos.org/opengl/wiki/Depth_Test
  - OpenGL Wiki (glEnable/glDisable): https://www.khronos.org/opengl/wiki/GLAPI/glEnable
  - OpenGL Wiki (per-buffer blending, glBlendFunci): https://www.khronos.org/opengl/wiki/GLAPI/glBlendFunc
  - KHR_debug (object labels): https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt

☐ Phase 0 — Inventory + Baseline Defaults
  Exit artifacts:
    - A single “default baseline” definition agreed upon (GL-spec defaults vs engine baseline)
    - Enumerated list of state knobs included in PSO, aligned with current VGE usage

  Work items:
    ☐ Decide baseline default semantics:
      - Option A: OpenGL specification defaults (portable, but may not match engine expectations)
      - Option B: Vintagestory/VGE render baseline (safer integration; document how to restore)
    ☐ Enumerate PSO state knobs based on existing code:
      - Depth test enable, depth func, depth write mask
      - Blend enable + blend factors (global)
      - Per-render-target blend enable/factors (MRT)
      - Cull enable (optionally cull face + front-face later)
      - Color mask (RGBA)
      - Scissor enable (scissor box remains dynamic unless explicitly included)
      - (Optional) line width / point size for debug-only pipelines
    ☐ Decide what is “dynamic state” (set outside PSO): viewport, scissor box, FBO binds, textures/samplers, uniforms

☐ Phase 1 — State ID Layout + Bitsets
  Exit artifacts:
    - A stable enum/ID mapping from “state knob” → bit index
    - Two compact bitsets in PSO (and optionally in cache snapshot)

  Work items:
    ☐ Define a `GlPipelineStateId` (or similar) enum for each tracked knob
    ☐ Choose a bitset representation:
      - Prefer `ulong` (<= 64 knobs) or a small fixed `ulong[]` for extension
      - Avoid `bool[]` for hot-path comparisons
    ☐ Define PSO invariants and validation checks (debug-only):
      - No overlap between defaultMask/nonDefaultMask
      - All required value fields are populated when their bits are set

☐ Phase 2 — Value Payloads (Non-Default State Storage)
  Exit artifacts:
    - A `GlPipelineDesc` / `GlPipelineState` that stores only necessary values for bits in nonDefaultMask

  Work items:
    ☐ Define compact value types:
      - Depth: enable (bit), func (enum), write mask (bool)
      - Blend: enable (bit), factors (src/dst, optionally separate RGB/alpha)
      - MRT blend: arrays by attachment index (enable + factors) matching your G-buffer usage
      - Color mask: 4 booleans packed into a nibble/byte
      - Scissor: enable (bit) (box stays dynamic unless explicitly requested)
    ☐ Decide ownership model for bindings:
      - PSO references program/VAO (owned elsewhere) vs PSO owns and disposes

☐ Phase 3 — GlStateCache + Apply/Diff Algorithm
  Exit artifacts:
    - A `GlStateCache` (or similar) that remembers the last applied state and skips redundant GL calls
    - `Apply(pso)` sets only what’s needed using the masks

  Work items:
    ☐ Implement cached setters per knob (Enable/Disable depth, blend, cull, scissor, etc.)
    ☐ Apply order definition (consistent & predictable):
      - Enables/disables, funcs/masks, then per-RT blend (or vice versa, but be consistent)
    ☐ Implement “dirtying rules” for external stomps:
      - When a global blend func changes, mark MRT per-attachment blend state as dirty so it can be re-emitted
      - Keep in sync with `GBufferManager` behavior
    ☐ Optional: provide a scoped state restore helper for legacy code paths

☐ Phase 4 — Integrate in One Renderer (Low Risk)
  Exit artifacts:
    - One concrete renderer uses PSO apply instead of ad-hoc state pokes
    - Output is identical to pre-PSO behavior

  Suggested target:
    ☐ Convert LumOn debug overlay path (point size/line width + depth/blend/scissor) to use a PSO

  Work items:
    ☐ Create a dedicated debug PSO descriptor:
      - Depth test off or configured as needed
      - Blend enabled (if overlay), plus blend func
      - Scissor forced disabled (if overlay must ignore engine scissor)
      - Debug-only dynamic state: viewport, point size, line width
    ☐ Remove per-frame save/restore where PSO makes it redundant (keep minimal safe restore if needed)

☐ Phase 5 — Expand to Offscreen Passes + MRT Blend
  Exit artifacts:
    - Offscreen passes use PSO for their fixed state
    - MRT blend state is robust against engine/global state stomps

  Work items:
    ☐ Apply PSO to atlas bake path “known-good state”
    ☐ Apply PSO to G-buffer creation/usage paths
    ☐ Verify per-attachment blending remains correct across frames

☐ Phase 6 — Debugging, Naming, and Documentation
  Exit artifacts:
    - Easy to debug “what state did we think we set?”
    - A short doc describing default baseline + included knobs + dynamic knobs

  Work items:
    ☐ Add a `Name` field and optional KHR_debug labels for related GL objects
    ☐ Add `ToString()` / dump helper for masks + values (debug-only)
    ☐ Document the baseline default and the tracked knob list in a markdown note

☐ Phase 7 — Validation + Performance
  Exit artifacts:
    - Confidence that PSO application doesn’t regress rendering or performance

  Work items:
    ☐ Add a micro-profiler counter (if you already have one) for:
      - GL calls avoided via cache
      - PSO applies per frame
    ☐ Add a sanity test harness (where feasible) that applies sequences of PSOs and asserts cache state
    ☐ Verify no unexpected interaction with engine state (especially scissor/viewport and blending)
```