```todo
VGE - PBRMaterialRegistry (Per-Mod Material Definitions + Shader Parameters)

  Goal:
  Create a `PBRMaterialRegistry` system that:
    - discovers and loads `materials/pbr_material_definitions.json` from any mod that provides it
    - builds mapping dictionaries:
        1) MaterialId -> PBRMaterialDefinition
        2) Texture AssetLocation -> MaterialId
        - enables patched base-game shaders to resolve materials and write the resulting values into the `gMaterial` buffer

  Context / Known Constraints:
    - VGE already has a custom GLSL `@import` preprocessor pipeline and shader patch hook.
    - The G-buffer already has a “material” attachment (currently expected layout: roughness, metallic, emissive, reflectivity).
    - Avoid expensive per-frame work: definitions/mappings should be built once on asset load and reused.
    - Must be deterministic across clients/servers for visuals; for now assume client-side only unless later needed for gameplay.
        - VGE already ships a reference `materials/pbr_material_definitions.json` describing base-game PBR values; use it as the schema exemplar.

  Non-goals (v1):
    - Automatically generating *_pbr.png maps at runtime (offline pipeline exists separately).
    - Supporting arbitrary shader graph or per-block runtime authored materials.
        - Passing material parameters directly to VGE-owned shader programs (material values are written by patched base-game shaders into `gMaterial`).


  Phase 1 - Schema + API Design
  Exit artifacts: JSON schema is agreed; C# model types exist; conflict/merge semantics are documented.
    [x] Decision: MaterialIds are fully-qualified strings `"<modid>:<name>"`.
    [x] Decision: each material receives a numeric `MaterialIndex` assigned at runtime (used as the numeric ID in shaders).
  [x] Define `PBRMaterialDefinition` fields (initial):
      [x] roughness (0..1)
      [x] metallic (0..1)
      [x] emissive (0..1)
      [x] reflectivity is computed in the patched shader (not authored/stored in definitions)
      [x] noise (optional): defines randomized variation mixed into PBR values by shader
          [x] Decision: `noise` specifies per-channel delta ranges for (roughness, metallic, emissive, reflectivity) and also normals.
          [x] Decision: shaders use Squirrel3 noise to generate a deterministic random scalar per channel, multiply by delta-range, then apply as a delta to the channel (or normal angle).
      [x] optional notes/debugName
      [x] priority (optional): numeric priority used to order/override materials across mods
  [x] Add schema doc: `docs/PBRMaterialDefinitions.schema.md`
    [x] Add JSON Schema file: `schemas/pbr_material_definitions.schema.json`
  [x] Add JSON DTO model types: `VanillaGraphicsExpanded/PBR/Materials/PbrMaterialDefinitionsModels.cs`
  [x] Define JSON schema for `materials/pbr_material_definitions.json`:
      [x] `version` (int)
      [x] optional `$schema` and `notes`
      [x] `defaults` block (values + noise)
      [x] `materials` map (id -> property overrides; ids may be local or fully-qualified)
      [x] `mapping` list (ordered rules)
  [x] Decide mapping rule match types:
      [x] v1 supports `match.glob` (standard globstar syntax) against `assets/<domain>/<path>`
      [x] defer additional match types (exact/prefix/regex) unless proven necessary
  [x] Allow a per-mapping `priority` value (optional) to influence deterministic ordering/override.
  [x] Decide conflict resolution strategy:
      [x] MaterialId collisions: higher `priority` wins; on tie use deterministic load order (stable domain/modid then file order)
      [x] Texture mapping collisions: higher mapping `priority` wins; on tie use deterministic rule order (stable domain/modid then file order then later mapping wins)
  [x] Decide warning/error policy:
      [x] warn on unknown MaterialId referenced by a mapping rule
      [x] do not warn per-texture for unmapped textures; log summary counts (optional)
      [x] strict mode toggle (dev-only): treat unknown materials / invalid rules as errors


  Phase 2 - Asset Discovery + Load Order
  Exit artifacts: registry can enumerate all mods and load all available definitions deterministically.
  [x] Choose load timing:
      [x] build registry at `AssetsLoaded`
      [ ] rebuild on asset reload event (if supported)
  [x] Implement asset discovery across all domains:
      [x] search for asset path `materials/pbr_material_definitions.json` in every domain
      [x] parse JSON into DTOs (via `IAsset.ToObject<T>()`)
  [x] Decide deterministic merge order:
      [x] stable sort by domain/modid
      [x] Decision: do not support an explicit `priority` field; ordering is derived from stable domain/modid rules
      [x] Decision: allow per-material and per-mapping `priority` (not per-file) and define the exact sort/override rules:
          [ ] higher priority wins when multiple rules assign the same texture
          [ ] when priorities tie: stable domain/modid order, then file order, then mapping order
  [x] Add basic diagnostics:
      [x] log how many definition files found
      [x] log how many materials + mapping rules loaded
      [ ] log collisions (and how resolved)


  Phase 3 - Registry Data Structures
  Exit artifacts: in-memory registries exist and are queryable with stable behavior.
  [x] Implement registry core:
      [x] `Dictionary<string, PBRMaterialDefinition> MaterialById`
      [x] `Dictionary<AssetLocation, string> MaterialIdByTexture`
      [x] `Dictionary<string, int> MaterialIndexById`
      [x] `PBRMaterialDefinition[] MaterialsByIndex`
  [x] Build mapping resolution:
      [x] apply mapping rules in decided order
      [x] resolve to a final `MaterialId` per texture
      [ ] allow per-rule property overrides (optional)
  [x] Implement glob matching engine for texture mapping:
      [ ] Use standard globstar syntax only:
          [ ] `*` matches within a single path segment (does not cross `/`)
          [ ] `?` matches a single character within a segment (does not match `/`)
          [ ] `**` matches across path segments (may cross `/`)
      [x] normalize AssetLocation paths for matching (slash direction, case rules, extension handling)
      [x] translate each glob rule into a regex pattern string once (at assets load)
      [x] compile a `Regex` instance per rule and cache it for fast resolution
          [x] note: JSON-authored patterns are runtime values; `[GeneratedRegex]` is not applicable here
          [x] use safe options where available (e.g., `RegexOptions.NonBacktracking`) and set timeouts if needed
      [x] add unit tests for: `**` behavior and deterministic ordering
  [ ] Decide caching granularity:
      [x] Decision: eagerly pre-expand glob rules into concrete AssetLocations (eager)
          [x] enumerate all candidate texture assets once at AssetsLoaded
          [x] apply mapping rules in deterministic order and materialize `MaterialIdByTexture`
          [x] log stats: total textures scanned, mapped, and unmapped (optional)
  [x] Provide query APIs:
      [x] `TryGetMaterial(string materialId, out PBRMaterialDefinition def)`
      [x] `TryGetMaterialId(AssetLocation texture, out string materialId)`
      [x] `TryGetMaterial(AssetLocation texture, out PBRMaterialDefinition def)`


  Phase 4 - Integrate With Rendering (MaterialId Source)
  Exit artifacts: renderer/shaders have a clear source of “which material applies” for a shaded fragment.
  [x] Confirm runtime pipeline:
            [x] patched base-game shaders resolve material assignment and write material values to `gMaterial`
      [x] VGE PBR passes read `gMaterial` (no direct registry access in those passes)
    [x] Known inputs / constraints:
      [x] Block/terrain shaders use `layout(location = 3) in int renderFlagsIn;` (or `flags`) and pass it as `flat out int renderFlags`.
      [x] Bit layout is defined in `assets/game/shaderincludes/vertexflagbits.ash` and consumes all bits 0..31 (glow/zOffset/reflective/lod0/normal/wind).
      [x] Non-SSBO path already uses custom attribs at locations 4..6 (colormap / uv2 / waterFlags).
      [x] SSBO terrain path exists and provides per-face data via `FaceData` (SSBO) consumed by shaders.
      [x] Decision: do NOT pack `MaterialIndex` into `renderFlags` (no spare bits).
  [ ] Implement material param data textures (aligned to atlas UVs):
      [x] Decision (v1): avoid tessellator patching by storing per-texture material params in a data texture addressed by the same atlas UVs used for the albedo atlas.
      [x] Multiple atlases are supported by creating one material-data texture per atlas texture id.
      [x] Note: non-SSBO (classic VBO vertex attributes) path may need to be implemented later.
      [ ] Choose data texture format:
          [x] Noise is computed in-shader (not baked into the stored values).
          [x] Base params texture: RGB16F storing (roughness, metallic, emissive); compute reflectivity in shader
          [ ] Optional noise deltas texture: RGBA16F or RGB16F storing per-channel delta ranges used by shader noise
      [ ] Build per-atlas material-data textures at client `AssetsLoaded`/`StartClientSide`:
          [x] iterate `capi.BlockTextureAtlas.AtlasTextures` and allocate matching `DynamicTexture` (same width/height)
          [x] for each mapped texture AssetLocation, get `TextureAtlasPosition` and fill its rectangle region with material params
          [x] define fallback behavior for unmapped textures (defaults)
      [ ] Bind alongside the block atlas during chunk rendering:
          [x] patch the engine texture-binding point for `terrainTex`/`terrainTexLinear` to also bind the matching material-data texture
          [x] inject a new `sampler2D` into patched chunk fragment shaders and sample it at `uv`
  [ ] Update vanilla shader patch injection plan:
      [x] sample per-texture params from the per-atlas material data texture using the same `uv` used for `terrainTex`
      [x] write `vec4(roughness, metallic, emissive, reflectivity)` to `gMaterial` (reflectivity computed in shader)
      [ ] ensure deterministic noise (stable seed inputs; no frame-dependent randomness unless explicitly desired)


  Phase 5 - GPU Parameter Transport Decision (Material UBO vs Data Texture)
  Exit artifacts: we pick one approach and can read per-texture PBR parameters in GLSL.
  [-] Decide expected scale:
      [-] target number of materials (estimate)
      [-] target number of unique textures mapped (estimate)
  [-] Evaluate approaches (used by patched base-game shaders):
      [ - UBO (uniform block) - simplest indexing but size-limited and requires a stable dense `MaterialIndex`
      [x] Data texture (2D, sampled by atlas UV) - scales with atlas size and naturally supports multiple atlases
  [x] Decision: use per-atlas data textures for material parameters.
      [x] Rationale: avoids tessellator patching, supports multiple atlases, and uses the same UVs as `terrainTex`.


  Phase 6 - Implement GPU Material Data Textures
  Exit artifacts: GPU resource(s) exist with per-texture params and are bound for patched base-game shaders.
  [x] Choose encoding:
      [x] Decision: do not bake noise into stored params; compute noise in shader.
      [x] Decision: compute `reflectivity` in the patched base-game shader and write it to `gMaterial`.
      [x] Base params texture format: RGB16F (roughness, metallic, emissive)
      [ ] Optional noise deltas texture format: RGB16F or RGBA16F (per-channel delta ranges)
  [x] Allocate/update GPU resources:
      [x] create one material params texture per block atlas page (`capi.BlockTextureAtlas.AtlasTextures`)
      [x] fill atlas rects for mapped textures using `TextureAtlasPosition` (x1..y2) and chosen defaults for unmapped
      [x] rebuild on shader reload and/or texture atlas reload (if available)
  [x] Bind in shader pipeline:
      [x] bind the correct per-atlas material params texture whenever the engine binds `terrainTex` for that atlas page
      [x] ensure binding survives shader reload / recompile
  [x] Add shader helper include:
      [x] `vec3 ReadMaterialParams(vec2 uv)` (roughness, metallic, emissive)
      [x] `vec3 ApplyMaterialNoise(vec3 params, ...)` (or equivalent helper) used by patched base-game shaders
      [x] `float ComputeReflectivity(float roughness, float metallic, ...)` used by patched base-game shaders


  Phase 7 - Shader/G-Buffer Plumbing
  Exit artifacts: shaders can obtain a material index/params per pixel, consistent with G-buffer layout.
    [x] Decision: `gMaterial` layout does not change; it stores params directly (roughness/metallic/emissive/reflectivity).
  [x] Implement chosen option:
      [x] Update vanilla shader patch injection codepaths
      [x] Update PBR direct lighting shader reads
      [x] Update composite shader reads
  [ ] Ensure noise behavior is testable/diagnosable:
      [ ] add debug toggles: disable noise, visualize noise contribution per channel
  [x] Add debug visualization mode(s):
      [x] show materialIndex as color bands (via MaterialBands hash proxy)
      [x] show roughness/metallic channels


  Phase 8 - Validation + Tests
  Exit artifacts: unit tests cover parsing/merge/mapping; runtime sanity checks exist.
  [ ] Add unit tests for JSON parsing:
      [ ] defaults apply correctly
      [ ] material overrides apply correctly
      [ ] mapping rule ordering is honored
  [ ] Add unit tests for merge semantics:
      [ ] collision behavior matches policy
  [ ] Add runtime diagnostics tests (if applicable in this repo):
      [ ] material data textures create expected size/format per atlas page
      [ ] shader can sample material data textures without GL errors (smoke)


  Phase 9 - Documentation + Modder UX
  Exit artifacts: modders can author the file correctly; troubleshooting guidance exists.
  [ ] Add a short doc:
      [ ] schema reference + examples
      [ ] how to map textures
      [ ] conflict resolution + best practices
  [ ] Confirm the existing VGE reference `pbr_material_definitions.json` is up to date with the schema and serves as the canonical example.
  [ ] Add logging guidance:
      [ ] how to enable debug output
      [ ] common errors and fixes


  Phase 10 - Future Enhancements (Optional)
  [ ] Support block/item code mappings (semantic assignment instead of texture-based)
  [ ] Support per-variant/seasonal textures
  [ ] Support hot reload of registry without restart
  [ ] Support authoring-time tooling to validate mappings and report unmapped textures

```