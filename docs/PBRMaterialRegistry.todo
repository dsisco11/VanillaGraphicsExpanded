```todo
VGE - PBRMaterialRegistry (Per-Mod Material Definitions + Shader Parameters)

  Goal:
  Create a `PBRMaterialRegistry` system that:
    - discovers and loads `materials/pbr_material_definitions.json` from any mod that provides it
    - builds mapping dictionaries:
        1) MaterialId -> PBRMaterialDefinition
        2) Texture AssetLocation -> MaterialId
        - enables patched base-game shaders to resolve materials and write the resulting values into the `gMaterial` buffer

  Context / Known Constraints:
    - VGE already has a custom GLSL `@import` preprocessor pipeline and shader patch hook.
    - The G-buffer already has a “material” attachment (currently expected layout: roughness, metallic, emissive, reflectivity).
    - Avoid expensive per-frame work: definitions/mappings should be built once on asset load and reused.
    - Must be deterministic across clients/servers for visuals; for now assume client-side only unless later needed for gameplay.
        - VGE already ships a reference `materials/pbr_material_definitions.json` describing base-game PBR values; use it as the schema exemplar.

  Non-goals (v1):
    - Automatically generating *_pbr.png maps at runtime (offline pipeline exists separately).
    - Supporting arbitrary shader graph or per-block runtime authored materials.
        - Passing material parameters directly to VGE-owned shader programs (material values are written by patched base-game shaders into `gMaterial`).


  Phase 1 - Schema + API Design
  Exit artifacts: JSON schema is agreed; C# model types exist; conflict/merge semantics are documented.
    [x] Decision: MaterialIds are fully-qualified strings `"<modid>:<name>"`.
    [x] Decision: each material receives a numeric `MaterialIndex` assigned at runtime (used as the numeric ID in shaders).
  [x] Define `PBRMaterialDefinition` fields (initial):
      [x] roughness (0..1)
      [x] metallic (0..1)
      [x] emissive (0..1)
      [x] reflectivity is computed in the patched shader (not authored/stored in definitions)
      [x] noise (optional): defines randomized variation mixed into PBR values by shader
          [x] Decision: `noise` specifies per-channel delta ranges for (roughness, metallic, emissive, reflectivity) and also normals.
          [x] Decision: shaders use Squirrel3 noise to generate a deterministic random scalar per channel, multiply by delta-range, then apply as a delta to the channel (or normal angle).
      [x] optional notes/debugName
      [x] priority (optional): numeric priority used to order/override materials across mods
  [x] Add schema doc: `docs/PBRMaterialDefinitions.schema.md`
    [x] Add JSON Schema file: `schemas/pbr_material_definitions.schema.json`
  [x] Add JSON DTO model types: `VanillaGraphicsExpanded/PBR/Materials/PbrMaterialDefinitionsModels.cs`
  [x] Define JSON schema for `materials/pbr_material_definitions.json`:
      [x] `version` (int)
      [x] optional `$schema` and `notes`
      [x] `defaults` block (values + noise)
      [x] `materials` map (id -> property overrides; ids may be local or fully-qualified)
      [x] `mapping` list (ordered rules)
  [x] Decide mapping rule match types:
      [x] v1 supports `match.glob` (standard globstar syntax) against `assets/<domain>/<path>`
      [x] defer additional match types (exact/prefix/regex) unless proven necessary
  [x] Allow a per-mapping `priority` value (optional) to influence deterministic ordering/override.
  [x] Decide conflict resolution strategy:
      [x] MaterialId collisions: higher `priority` wins; on tie use deterministic load order (stable domain/modid then file order)
      [x] Texture mapping collisions: higher mapping `priority` wins; on tie use deterministic rule order (stable domain/modid then file order then later mapping wins)
  [x] Decide warning/error policy:
      [x] warn on unknown MaterialId referenced by a mapping rule
      [x] do not warn per-texture for unmapped textures; log summary counts (optional)
      [x] strict mode toggle (dev-only): treat unknown materials / invalid rules as errors


  Phase 2 - Asset Discovery + Load Order
  Exit artifacts: registry can enumerate all mods and load all available definitions deterministically.
  [x] Choose load timing:
      [x] build registry at `AssetsLoaded`
      [ ] rebuild on asset reload event (if supported)
  [x] Implement asset discovery across all domains:
      [x] search for asset path `materials/pbr_material_definitions.json` in every domain
      [x] parse JSON into DTOs (via `IAsset.ToObject<T>()`)
  [x] Decide deterministic merge order:
      [x] stable sort by domain/modid
      [x] Decision: do not support an explicit `priority` field; ordering is derived from stable domain/modid rules
      [x] Decision: allow per-material and per-mapping `priority` (not per-file) and define the exact sort/override rules:
          [ ] higher priority wins when multiple rules assign the same texture
          [ ] when priorities tie: stable domain/modid order, then file order, then mapping order
  [x] Add basic diagnostics:
      [x] log how many definition files found
      [x] log how many materials + mapping rules loaded
      [ ] log collisions (and how resolved)


  Phase 3 - Registry Data Structures
  Exit artifacts: in-memory registries exist and are queryable with stable behavior.
  [x] Implement registry core:
      [x] `Dictionary<string, PBRMaterialDefinition> MaterialById`
      [x] `Dictionary<AssetLocation, string> MaterialIdByTexture`
      [x] `Dictionary<string, int> MaterialIndexById`
      [x] `PBRMaterialDefinition[] MaterialsByIndex`
  [x] Build mapping resolution:
      [x] apply mapping rules in decided order
      [x] resolve to a final `MaterialId` per texture
      [ ] allow per-rule property overrides (optional)
  [x] Implement glob matching engine for texture mapping:
      [ ] Use standard globstar syntax only:
          [ ] `*` matches within a single path segment (does not cross `/`)
          [ ] `?` matches a single character within a segment (does not match `/`)
          [ ] `**` matches across path segments (may cross `/`)
      [x] normalize AssetLocation paths for matching (slash direction, case rules, extension handling)
      [x] translate each glob rule into a regex pattern string once (at assets load)
      [x] compile a `Regex` instance per rule and cache it for fast resolution
          [x] note: JSON-authored patterns are runtime values; `[GeneratedRegex]` is not applicable here
          [x] use safe options where available (e.g., `RegexOptions.NonBacktracking`) and set timeouts if needed
      [x] add unit tests for: `**` behavior and deterministic ordering
  [ ] Decide caching granularity:
      [x] Decision: eagerly pre-expand glob rules into concrete AssetLocations (eager)
          [x] enumerate all candidate texture assets once at AssetsLoaded
          [x] apply mapping rules in deterministic order and materialize `MaterialIdByTexture`
          [x] log stats: total textures scanned, mapped, and unmapped (optional)
  [x] Provide query APIs:
      [x] `TryGetMaterial(string materialId, out PBRMaterialDefinition def)`
      [x] `TryGetMaterialId(AssetLocation texture, out string materialId)`
      [x] `TryGetMaterial(AssetLocation texture, out PBRMaterialDefinition def)`


  Phase 4 - Integrate With Rendering (MaterialId Source)
  Exit artifacts: renderer/shaders have a clear source of “which material applies” for a shaded fragment.
  [ ] Confirm runtime pipeline:
      [ ] patched base-game shaders resolve material assignment and write material values to `gMaterial`
      [ ] VGE PBR passes read `gMaterial` (no direct registry access in those passes)
    [x] Decision: explore Option B first (base-game already supports custom vertex attribute flags).
      [ ] Identify existing vertex attribute flags available to shaders and how they are authored by tessellators.
      [ ] Decide how a flag (or small bitfield) maps to `MaterialIndex` (direct index vs indirection table).
      [ ] Determine whether base-game tessellator overrides are required to author the new attributes:
          [ ] if yes: create a dedicated plan for tessellator override scope, compatibility, and fallback behavior
          [ ] if no: document how flags are sourced for blocks/items and how mods opt-in
  [ ] Update vanilla shader patch injection plan:
      [ ] inject code that produces final PBR values (including noise) and writes `vec4(roughness, metallic, emissive, reflectivity)` to `gMaterial`
      [ ] ensure deterministic noise (stable seed inputs; no frame-dependent randomness unless explicitly desired)


  Phase 5 - GPU Parameter Transport Decision (UBO vs Data Texture)
  Exit artifacts: we pick one approach and can read per-material parameters in GLSL.
  [ ] Decide expected scale:
      [ ] target number of materials (estimate)
      [ ] target number of unique textures mapped (estimate)
  [ ] Evaluate approaches (used by patched base-game shaders):
      [ ] UBO (uniform block) - simplest indexing but size-limited and requires shader block definition
      [ ] Data texture (1D/2D, texelFetch) - scales to many materials and matches existing texture-binding patterns
  [x] Decision: use a UBO for the material parameter table.
      [ ] Query `GL_MAX_UNIFORM_BLOCK_SIZE` at runtime and compute max supported material count for our chosen struct packing.
      [ ] If we exceed the UBO limit in the future, add a data-texture fallback (defer until needed).


  Phase 6 - Implement GPU Material Table
  Exit artifacts: GPU resource exists with material params and is bound for PBR passes.
  [ ] Choose encoding:
      [x] Decision: do not store `reflectivity` in the table; compute it in the patched base-game shader and write it to `gMaterial`.
      [ ] Define UBO packing (std140-friendly), recommended:
          [ ] `vec4 pbrParams` = (roughness, metallic, emissive, unused)
          [ ] `vec4 noiseDeltas` = (roughDelta, metalDelta, emissiveDelta, normalDelta)
  [ ] Assign stable numeric `MaterialIndex`:
      [ ] build `Dictionary<string, int> MaterialIndexById`
      [ ] build `PBRMaterialDefinition[] MaterialsByIndex`
  [ ] Allocate/update GPU resource:
      [ ] allocate UBO for `MaterialsByIndex` once at AssetsLoaded and on reload
      [ ] upload UBO data (buffer subdata or orphan+upload) after registry rebuild
  [ ] Bind in shader pipeline:
      [ ] bind material UBO + any mapping resources for patched base-game shaders (the stage that writes `gMaterial`)
      [ ] ensure binding also works during shader reload / recompile
  [ ] Add shader helper include:
      [ ] `vec3 ReadMaterialParams(int materialIndex)` (roughness, metallic, emissive)
      [ ] `vec4 ApplyMaterialNoise(vec4 params, ...)` (or equivalent helper) used by patched base-game shaders
      [ ] `float ComputeReflectivity(float roughness, float metallic, ...)` used by patched base-game shaders


  Phase 7 - Shader/G-Buffer Plumbing
  Exit artifacts: shaders can obtain a material index/params per pixel, consistent with G-buffer layout.
    [x] Decision: `gMaterial` layout does not change; it stores params directly (roughness/metallic/emissive/reflectivity).
  [ ] Implement chosen option:
      [ ] Update vanilla shader patch injection codepaths
      [ ] Update PBR direct lighting shader reads
      [ ] Update composite shader reads
  [ ] Ensure noise behavior is testable/diagnosable:
      [ ] add debug toggles: disable noise, visualize noise contribution per channel
  [ ] Add debug visualization mode(s):
      [ ] show materialIndex as color bands
      [ ] show roughness/metallic channels


  Phase 8 - Validation + Tests
  Exit artifacts: unit tests cover parsing/merge/mapping; runtime sanity checks exist.
  [ ] Add unit tests for JSON parsing:
      [ ] defaults apply correctly
      [ ] material overrides apply correctly
      [ ] mapping rule ordering is honored
  [ ] Add unit tests for merge semantics:
      [ ] collision behavior matches policy
  [ ] Add runtime diagnostics tests (if applicable in this repo):
      [ ] material table upload creates expected size/format
      [ ] shader can sample table without GL errors (smoke)


  Phase 9 - Documentation + Modder UX
  Exit artifacts: modders can author the file correctly; troubleshooting guidance exists.
  [ ] Add a short doc:
      [ ] schema reference + examples
      [ ] how to map textures
      [ ] conflict resolution + best practices
  [ ] Confirm the existing VGE reference `pbr_material_definitions.json` is up to date with the schema and serves as the canonical example.
  [ ] Add logging guidance:
      [ ] how to enable debug output
      [ ] common errors and fixes


  Phase 10 - Future Enhancements (Optional)
  [ ] Support block/item code mappings (semantic assignment instead of texture-based)
  [ ] Support per-variant/seasonal textures
  [ ] Support hot reload of registry without restart
  [ ] Support authoring-time tooling to validate mappings and report unmapped textures

```