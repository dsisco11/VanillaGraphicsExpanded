PBR / MaterialAtlas - Parallax Occlusion Mapping (POM) + Atlas-Stable UV Rects:

  Goal:
  Add Parallax Occlusion Mapping (POM) support to VGE’s block/terrain shading in an atlas-safe way.
  “Atlas-safe” means: ray-marched UVs must stay within the current face’s atlas tile rect, avoiding
  cross-tile sampling, shimmer, and “swimming” under camera motion.

  Why this is needed:
  - Liquids already carry `uvBase`/`uvSize` for stable atlas-local UV math.
  - Non-liquid chunk shaders currently only expose `uv`, so any parallax UV indirection can easily
    cross tile boundaries or become temporally unstable.


  References (repo):
  - docs/MaterialAtlas.Architecture.md
  - docs/MaterialAtlas.BuildPipeline.md
  - docs/NormalDepthBake.md
  - VanillaGraphicsExpanded/PBR/VanillaShaderPatches.cs
  - VanillaGraphicsExpanded/assets/vanillagraphicsexpanded/shaders/includes/vge_normaldepth.glsl
  - VanillaGraphicsExpanded/assets/vanillagraphicsexpanded/shaders/includes/vge_parallax.glsl

  References (engine shader sources):
  - g:/Vintagestory/assets/game/shaders/chunkliquid.vsh (source of `uvBase`/`uvSize`)
  - g:/Vintagestory/assets/game/shaders/chunkliquid.fsh (consumes `uvBase`/`uvSize`)
  - g:/Vintagestory/assets/game/shaders/chunkopaque.vsh
  - g:/Vintagestory/assets/game/shaderincludes/vertexflagbits.ash (FaceData + UnpackUv)

  References (external docs):
  - LearnOpenGL (Parallax Mapping): https://learnopengl.com/Advanced-Lighting/Parallax-Mapping
  - GPU Gems 3 (Parallax Occlusion Mapping / relief mapping variants): https://developer.nvidia.com/gpugems/gpugems3
  - UE docs (POM material function overview): https://docs.unrealengine.com/ (search: "Parallax Occlusion Mapping")


  Key Findings (current state):
  - Liquid shader path:
    - chunkliquid.vsh computes:
      - `uvSize = vec2((waterFlagsIn >> 10) & 0xff, (waterFlagsIn >> 18) & 0xff) * (1/255) * blockTextureSize`
      - `uvBase = uv - uvSize`
    - `uvBase` is declared `flat out` so it is constant for the quad.
    - `uvSize` is interpolated and represents the per-vertex offset from `uvBase` to the current corner.
  - Non-liquid chunk shaders:
    - chunkopaque.vsh / chunktransparent.vsh / chunktopsoil.vsh output only `uv` (and `uv2` for topsoil).
    - In the SSBO path (`USESSBO > 0`), UVs are derived from `FaceData` via `UnpackUv(...)`.
      `FaceData` contains packed UV origin (`vdata.uv`) and packed signed sizes/flags (`vdata.uvSize`).


  Phase 0 - Requirements + Success Criteria:
  Exit artifacts: We can define “done” and avoid regressions.
  ✔ Define feature tiers: @done
    - Tier 0: No parallax (baseline; raw atlas UV sampling)
    - Tier 1: Offset mapping (single-sample UV indirection; cheap)
    - Tier 2: POM (ray-march in heightfield + refine; atlas-rect clamped)
  ✔ Define acceptance criteria: @done
    - No cross-tile sampling (POM/offset UV always clamped to the face’s tile rect; verify via debug view)
    - No obvious swimming at mid/far distance (distance fade-out; stable mip behavior)
    - Grazing-angle shimmer controlled (angle-based step count + max offset clamp)
    - Configurable quality/perf knobs (scale, min/max steps, refinement steps, fade distances)
    - Safe failure mode (when prerequisites are missing/invalid, fall back to Tier 0/1 without visual corruption)
  ✔ Decide per-shader coverage: @done
    - First: chunkopaque/chunktransparent/chunktopsoil (terrain/blocks)
    - Deferred: chunkliquid (liquid flow UV logic is special; revisit after rect plumbing is proven)


  Phase 1 - UV Rect Plumbing (uvBase/uvSize) for Non-Liquid Shaders:
  Exit artifacts: chunk opaque/transparent/topsoil have stable per-face UV rects available in fragment.

  1.1 - Document liquid semantics (ground truth):
  ✔ Record the exact meaning of liquid `uvBase`/`uvSize` and how they are used in chunkliquid.fsh. @done
    - In chunkliquid.vsh:
      - `uvSize` is computed per-vertex from `waterFlagsIn` bits 10..17 (x) and 18..26 (y):
        it encodes the distance from the tile’s upper-left corner in units of 1/255 * `blockTextureSize`.
      - `uvBase = uv - uvSize` yields the atlas tile origin for the quad.
      - `uvBase` is `flat out` so the per-quad base does not drift via interpolation.
    - In chunkliquid.fsh:
      - Flow UV math is performed in tile-local space via `(uv - uvBase)` and then reassembled as `uvBase + uvxOffset`.
      - Offsets are clamped into the tile bounds using `blockTextureSize` and `textureAtlasSize`.
  ✔ Confirm what the waterFlags bitfields represent and why `uvBase` must be `flat`. @done
    - waterFlagsIn packs both behavior flags and the per-vertex “distance to upper-left” used to reconstruct the tile rect.
    - Because those distances differ per vertex, `uvBase` must be `flat` to remain a single stable per-face value.

  1.2 - Determine how to compute UV rect for non-liquid faces:
    ✔ SSBO path (`USESSBO > 0`): compute UV rect from `FaceData`. @done
     - Add a helper in an include (or injected code) to compute:
       - `uvBase` (tile origin in atlas UV space)
       - `uvExtent` (tile size in atlas UV space)
       - rotation/mirroring handling (from `vdata.uvSize` flags)
    ✔ Non-SSBO path (`USESSBO == 0`): decide fallback policy. @done
      - Decision: Option A for now (treat rect as unavailable; disable Tier 2 POM when rect is missing).
      - Rationale: non-SSBO chunk shaders do not expose packed `FaceData` UV extents or a reliable tile-size uniform.

  1.3 - Add varyings to non-liquid vertex shaders:
  ✔ Patch `chunkopaque.vsh`, `chunktransparent.vsh`, `chunktopsoil.vsh` to output: @done
    - `flat out vec2 vge_uvBase;`
    - `flat out vec2 vge_uvExtent;`
    - (optional) `out vec2 vge_uvLocal;` (atlas-local uv offset = uv - uvBase)
  ✔ Patch corresponding fragment shaders to consume these varyings. @done
  ✔ Decide naming conventions to avoid collisions and keep patches easy to grep. @done
    - Use `vge_uvBase` / `vge_uvExtent` (avoid collision with liquid’s existing `uvBase`)

  Notes:
  - VGE currently patches `.fsh` only. This phase likely requires extending the patch pipeline to also patch `.vsh`.
  - Use `flat` for base/extent to avoid interpolation drift across the quad.


  Phase 2 - Implement POM in Shared GLSL Include:
  Exit artifacts: A reusable POM function exists with strict rect-clamp and stable defaults.
  ✔ Add a new include (e.g. `vge_pom.glsl`) or expand `vge_parallax.glsl` with: @done
    - `VgeApplyPomUv_WithTbn(uv, tbn, handedness, worldPosWs, uvBase, uvExtent)`
    - Implemented as `assets/vanillagraphicsexpanded/shaders/includes/vge_pom.glsl`
  ✔ Implement algorithm: @done
    - View vector in tangent space
    - Angle-scaled step count (more at grazing angles)
    - Height ray-march in [0..1] depth space (derived from baked height)
    - Refine hit point (linear interpolate + small binary search)
  ✔ Enforce atlas safety: @done
    - Clamp final UV to the rect
    - Clamp per-step UV to rect to avoid “escape” during march
  ✔ Add stability controls: @done
    - Distance fade (configurable defaults)
    - Max UV offset clamp in texels
    - Guard NaN/Inf


  Phase 3 - Integrate POM into Vanilla Shader Patches:
  Exit artifacts: POM can be enabled per config and works end-to-end.
  ✔ Extend `VanillaShaderPatches` to patch both stages: @done
    - Preprocess: insert `@import` for `vge_pom.glsl` (fragment) and rect helpers (vertex)
    - Patch `.vsh` to emit UV rect varyings
    - Patch `.fsh` to use POM UV (with rect clamp) instead of raw `uv` for atlas sampling
  ✔ Define shader `#define`s for POM: @done
    - `VGE_PBR_ENABLE_POM`
    - `VGE_PBR_POM_SCALE`
    - `VGE_PBR_POM_MIN_STEPS`, `VGE_PBR_POM_MAX_STEPS`, `VGE_PBR_POM_REFINEMENT_STEPS`
    - `VGE_PBR_POM_FADE_START`, `VGE_PBR_POM_FADE_END`, `VGE_PBR_POM_MAX_TEXELS`
  ✔ Ensure POM UV indirection applies consistently to: @done
    - terrainTex sampling
    - vge_normalDepthTex sampling (height/normal atlas)
    - vge_materialParamsTex sampling


  Phase 4 - Debug Views + Validation:
  Exit artifacts: We can prove atlas safety and stability.
  ✔ Add a debug mode to visualize: @done
    - UV rect bounds (edge distance) via `MaterialAtlas.PomDebugMode = 1` (writes scalar into gBufferNormal.w)
    - Whether any POM step hits rect clamp via `MaterialAtlas.PomDebugMode = 2`
    - Effective step count via `MaterialAtlas.PomDebugMode = 3`
    - Fade/angle weight via `MaterialAtlas.PomDebugMode = 4`
    - Visualization: `lumon_debug.fsh` mode `LumOnDebugMode.PomMetrics` (41) heatmap output
  ✔ Add a “tile bleed test” texture/material to make cross-tile sampling obvious. @done
    - Implemented as a shader-driven test: use edge-distance + clamp-hit modes to expose bleed risk without adding binary texture assets.
  ✔ Record a short checklist for RenderDoc capture: @done
    - Capture a frame with POM enabled, PomDebugMode = 2 (clamp hit)
    - Verify `vge_normalDepthTex` is bound and sampled (inspect texture reads)
    - Verify `vge_uvBase`/`vge_uvExtent` are constant per face (flat varyings)
    - Verify POM march UV never exits rect (watch `VgeClampUvToRect` clamping behavior)
    - Verify gBufferNormal.w matches the selected debug metric and is stable over camera motion


  Phase 5 - Performance + Quality Tuning:
  Exit artifacts: Defaults are stable and performant.
  ☐ Profile GPU cost by view angle and distance.
  ☐ Tune step counts and fade thresholds.
  ☐ Add config validation bounds (avoid extreme scales).


  Phase 6 - Documentation + Modder/Config Surface:
  Exit artifacts: Feature is documented and safe for users.
  ☐ Update docs/NormalDepthBake.md with POM notes (height interpretation and scale).
  ☐ Document config knobs + recommended presets:
    - Low (few steps, strong fade)
    - Medium
    - High
  ☐ Document limitations:
    - SSBO dependency (if applicable)
    - liquid compatibility (if deferred)
