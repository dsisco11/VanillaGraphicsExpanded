PBR Material System - Average Base Color Disk Cache (DiffuseAlbedo Input)

Goal:
  Cache the *average base color* (linear RGB) derived from a texture’s bitmap to disk.
  On startup/reload: eagerly preload cached base colors.
  During runtime/loading: a background worker lazily evaluates staleness and regenerates cache misses off-thread.

Decisions (locked in for this todo):
  - Cache average base color, not final DiffuseAlbedo.
  - Treat AVX2 vs fallback averaging paths as equivalent (no CPU-path keying).
  - Reuse the existing cache key *type/hashing approach* (schema + Hash64), but use a purpose-built key string
    that does NOT include atlas-only inputs (normal/depth bake config, atlas sizing, etc).
  - Use a shared generic cache core and split feature specifics via feature-side `ICacheCodec<TPayload>` implementations.
  - Persist as a BaseColor namespace under `VintagestoryData/VGE/Cache/BaseColor/` (the `VGE/Cache` root is shared; BaseColor is feature-owned).
  - Staleness is purely key-based (if inputs differ -> miss -> regenerate); no asset byte hashing.
  - Value encoding is `RGB16F` (3x IEEE754 half) stored as raw `ushort` bit patterns.
  - Cache key uses `AssetLocation.ToString()` (e.g. `game:textures/...`) rather than the mapping match string;
    the mapping match string is an implementation detail of rule matching.

Reference docs:
  - docs/MaterialSystem.Cache.Architecture.md (cache key + disk store patterns)
  - docs/MaterialAtlas.Architecture.md (threading model + session cancellation)
  - docs/MaterialAtlas.BuildPipeline.md (budgeted async execution patterns)
  - docs/PBRMaterialRegistry.ModderGuide.md (material definitions + mapping rules)

Code touchpoints (expected):
  - VanillaGraphicsExpanded/PBR/Materials/PbrMaterialRegistry.cs (ComputeAverageAlbedo / ComputeDiffuseAlbedo)
  - VanillaGraphicsExpanded/PBR/Materials/PbrMaterialsModSystem.cs (startup/reload integration)
  - VanillaGraphicsExpanded/Imaging/AlbedoAverager.cs (bitmap averaging algorithm)
  - VanillaGraphicsExpanded/PBR/Materials/Cache/MaterialAtlasCacheKeyBuilder.cs (key type / hashing approach reference)

✔ Phase 0 - Design & Contracts
  Exit artifacts: key schema v1; value encoding; staleness rules; threading constraints documented.
  ✔ Confirm the exact cache unit:
    - Keyed by resolved base texture identity (`AssetLocation`, serialized via `AssetLocation.ToString()`)
    - Value = average base color in linear space (RGB) as produced by `AlbedoAverager.TryComputeAverageLinearRgb`
  ✔ Decide persistence location and tiering:
    - Global-only cache (match current `MaterialAtlasDiskCache.CreateDefault()` behavior)
    - Root: `VintagestoryData/VGE/Cache/BaseColor/` (under shared-core namespace; separate from atlas payloads)
    - Future: per-world overlay can be added once the atlas cache policy supports it
  ✔ Define cache staleness rule:
    - A cache entry is valid iff its computed cache key matches current inputs
    - No asset byte hashing (aligned with docs/MaterialSystem.Cache.Architecture.md)
    - Minimal provenance/metadata signals available today (from `IAsset`):
      - `tex=<asset.Location>`
      - `origin=<asset.Origin.OriginPath>` (or `(unknown)`)
      - `bytes=<asset.Data.Length>` (0 if missing)
      - `avgAlgo=1` (bump only if we intentionally change averaging behavior)
  ✔ Define value encoding:
    - `RGB16F` stored as 3x `ushort` half bit patterns (little-endian on disk)
    - Error bound is acceptable for a single averaged color; should not cause noticeable flicker
  ✔ Config + knobs:
    - `MaterialAtlas.EnableBaseColorCache` (read/write toggle)
    - `MaterialAtlas.EnableBaseColorBackgroundRegen` (regen worker toggle)
    - `MaterialAtlas.BaseColorRegenMaxConcurrency` (default small, e.g. 1-2)
    - Optional: `MaterialAtlas.BaseColorRegenMaxWritesPerMinute` (rate limiting)

  Threading note:
    - Regeneration runs off-thread; it will need to load/decode textures via `ICoreClientAPI.Assets` + `IAsset.ToBitmap`.
      This pattern already exists in `MaterialOverrideTextureLoader` and is treated as acceptable.

✔ Phase 1 - Generic Cache Core
  Exit artifacts: `IDataCacheSystem<TKey, TPayload>`, `ICacheStore`, `ICacheCodec<TPayload>`; blob store + JSON dictionary store; tests.
  ✔ Define shared-core abstractions:
    - `IDataCacheSystem<TKey, TPayload>` (coordinates memory + store + codec; no feature knowledge)
    - `ICacheStore` (persistence interface; read/write/delete/list; atomic writes; corruption handling)
    - `ICacheCodec<TPayload>` (feature-owned encode/decode + codec schema)
  ✔ Implement stores:
    - Blob store (key -> bytes; file-per-entry; atomic writes: temp + rename)
    - JSON dictionary store (key -> JSON payload; single file; atomic writes)
  ✔ Shared-core tests:
    - atomic write behavior
    - corruption recovery (skip + optional purge)
    - codec failures don’t poison the whole load

✔ Phase 2 - Migrate Material Atlas Cache to Shared Core
  Exit artifacts: material atlas disk cache uses shared core without changing behavior or on-disk format.
  ✔ Wrap/port `MaterialAtlasDiskCache` persistence behind `ICacheStore`
  ✔ Preserve existing:
    - folder layout + filenames
    - key hashing approach and schema
    - key-based staleness policy
  ✔ Regression tests:
    - on-disk compatibility (existing cache can be read)
    - no behavior change in atlas cache hit/miss counters

✔ Phase 3 - BaseColor Consumer via JSON Store
  Exit artifacts: base-color cache keys + payload codec; JSON store at `VintagestoryData/VGE/Cache/BaseColor/`.
  ✔ Add base-color key inputs + builder (feature-owned; reuse existing key container/hash approach):
    - `BaseColorCacheKeyInputs`
    - `BaseColorCacheKeyBuilder`
  ✔ Key contents (minimum viable; no pack/mod fingerprinting):
    - baseColorSchemaVersion
    - normalized texture asset id (domain + path, serialized via `AssetLocation.ToString()`)
    - `origin=<asset.Origin.OriginPath>` (or `(unknown)`)
    - `bytes=<asset.Data.Length>` (0 if missing)
    - `avgAlgo=<int>` (bump only for intentional averaging behavior changes)
  ✔ Define payload + codec:
    - Payload: average linear RGB in `RGB16F` (3x `ushort` half bit patterns)
    - Codec: `ICacheCodec<TPayload>` implementation for JSON dictionary store round-trip
  ✔ Unit tests:
    - stable key determinism across runs
    - key changes when origin/bytes/avgAlgo change
    - JSON store round-trip (payload fidelity + corruption tolerance)

✔ Phase 4 - Registry Integration + Preload
  Exit artifacts: computed DiffuseAlbedo uses cached base color when available; preload happens before first use.
  ✔ Add an in-memory map: `BaseColorCacheKey -> baseColorLinear` loaded at startup
  ✔ Eager preload path:
    - On StartClientSide/BlockTexturesLoaded: load JSON store into memory
    - On ReloadTextures: clear in-memory derived surfaces and re-preload base color cache
  ✔ Compute path integration:
    - `ComputeAverageAlbedo`: return cached base color when present
    - If missing: compute base color and enqueue a write (don’t block gameplay frames)
  ✔ Confirm invariants:
    - Cache does not change gameplay outputs (only avoids recomputation)
    - Any cache miss behaves exactly like today

✔ Phase 5 - Background Regen
  Exit artifacts: low-priority worker fills missing/stale base colors without blocking render thread.
  ✔ Add worker lifecycle:
    - Start after eager preload
    - Cancel on ReloadTextures and Dispose
    - Use “session id”/cancellation token model (drop stale results)
  ✔ Build regeneration worklist:
    - Enumerate all texture ids referenced by mapping rules/material plan (resolved, canonical)
    - Deduplicate keys
  ✔ Background job flow:
    - For each key: if missing/stale -> compute base color off-thread
    - Write-through to JSON store
    - Marshal update back to main thread to update the in-memory map
  ✔ Budgeting + telemetry:
    - limit concurrency; optional write rate limit
    - counts: preload hits/misses, regen scheduled/completed, errors
    - timings: avg compute time, IO time

✔ Phase 6 - Validation, Diagnostics, and Docs
  Exit artifacts: tests + debug surfaces/stats; documented behavior and knobs.
  ✔ Add tests for:
    - corrupt cache entry recovery
    - session cancellation drops stale results
    - cache hit avoids calling the expensive averaging path (where testable)
  ✔ Add a debug view and/or log line summarizing:
    - preload stats (hits/misses)
    - regen progress + completion
  ✔ Document in docs:
    - cache scope/policy (`VintagestoryData/VGE/Cache/BaseColor/` under shared-core namespace)
    - schema bump procedure when changing averaging behavior

Notes:
  - `DiffuseAlbedo` remains derived at runtime from (baseColorLinear, metallic).
  - CPU averaging path differences are treated as equivalent by design.
