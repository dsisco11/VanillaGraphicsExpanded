Texture Streaming - Persistent-Mapped StageCopy Refactor (Option B First):

  Goal:
  Refactor the generic texture streaming system so producers can immediately deep-copy pixel data into a
  persistent-mapped PBO ring (when supported), while the render thread performs the actual `glTexSubImage*`
  uploads later under per-frame budgets. When the bounded staging queue is full (or persistent staging is
  unavailable), fall back to the full-copy + stage-upload path (non-persistent/triple-buffered PBO backend).

  References:
  - docs/TextureStreaming.Architecture.md
  - VanillaGraphicsExpanded/Rendering/TextureStreamingManager.cs
  - VanillaGraphicsExpanded/Rendering/TextureStreamingManagerRenderer.cs
  - VanillaGraphicsExpanded/Rendering/TextureStreamingSystem.cs
  - VanillaGraphicsExpanded/Rendering/DynamicTexture.cs
  - VanillaGraphicsExpanded/Rendering/DynamicTexture3D.cs

  Notes / Constraints:
  - All GL object creation and mapping must happen on the render thread (GL context required).
  - After persistent mapping is established, the mapped pointer can be written by any CPU thread.
  - If using non-coherent mapping, producers must not call GL; the render thread flushes written ranges.
  - Option B priority handling now: single bounded MPMC queue + drain-to-list + stable sort per frame.
    Leave room to swap the queue/scheduler internals for Option A (multi-lane channels) later.
  - Avoid ring-space leaks when the queue is full: use admission control (queue slot reservation) before
    reserving/copying into the ring.


  Phase 0 - Baseline / Prereqs:
  Exit artifacts: We have shared primitives needed for the refactor and current behavior is documented.
  ✔ Add `GpuFence` abstraction wrapper @done
  ✔ Document current system + constraints in `TextureStreaming.Architecture.md` @done


  Phase 1 - Contracts + Producer API (StageCopy):
  Exit artifacts: A clear public contract exists for immediate deep-copy staging + async GPU upload.
  ✔ Define `TextureUploadPriority` (e.g., Low/Normal/High) and document semantics. @done
  ✔ Define `StageCopy(...)` API surface (manager/system), including: @done
    - texture target + sub-region + mip
    - pixel format/type + pixel store (alignment/rowLength/imageHeight)
    - typed input overloads (byte/ushort/Half/float)
    - optional priority parameter (defaults to Normal)
  ✔ Define result semantics (`TextureStageResult`): staged-to-ring vs fallback-enqueued vs dropped/rejected. @done
  ✔ Specify behavior when persistent staging is not ready yet (startup / no GL tick yet): @done
    - StageCopy still deep-copies immediately, but routes to fallback queue.
  ✔ Update docs: “Data Lifetime” becomes “safe to reuse input immediately” for StageCopy. @done


  Phase 2 - Queue + Scheduler Abstractions (Option B, extensible to A):
  Exit artifacts: Producers enqueue commands through a swappable internal queue/scheduler.
  ✔ Add internal `IUploadCommandQueue` (TryEnqueue + Drain into caller-provided buffer). @done
  ✔ Implement `SingleChannelUploadQueue` using bounded `System.Threading.Channels.Channel<T>`. @done
  ✔ Add admission control (queue slots) so StageCopy never reserves/copies into the ring if enqueue would fail. @done
  ✔ Add internal `IUploadScheduler` and implement “stable priority sort” (Priority desc, SequenceId asc). @done
  ✔ Ensure “hot path” is low/zero-GC (pool drain buffers; avoid per-upload allocations). @done
  ✔ Add per-priority diagnostics counters (enqueued/drained/fallback/failed). @done


  Phase 3 - Persistent-Mapped Ring: Producer-Side StageCopy:
  Exit artifacts: CPU threads can reserve ring space, memcpy pixels into mapped memory, and enqueue a render command.
  ✔ Refactor `PersistentMappedPboRing` to expose a thread-safe reserve/commit API. @done
  ✔ Implement ring allocation rules: @done
    - alignment (`PboAlignment`)
    - wrap-around handling
    - failure when insufficient contiguous space
  ✔ Implement StageCopy fast path: @done
    - acquire queue slot
    - reserve aligned bytes
    - memcpy into mapped pointer (managed → unmanaged)
    - enqueue `UploadCmd` referencing ring offset/size + upload metadata
  ✔ Track non-coherent flush requirements per command (record ranges; flush on render thread). @done
  ✔ Define behavior for oversize requests (bypass persistent ring → fallback path). @done


  Phase 4 - Render Thread: Drain, Upload, Fence, Retire:
  Exit artifacts: Render thread uploads from PBO offsets under budgets and advances the ring tail via fences.
  ☐ Drain commands into a temp list (bounded by `MaxUploadsPerFrame` / `MaxBytesPerFrame`).
  ☐ Order via scheduler (Option B stable sort).
  ☐ For each command:
    - flush mapped range if needed (non-coherent)
    - bind `GL_PIXEL_UNPACK_BUFFER` + apply pixel store
    - issue correct `glTexSubImage1D/2D/3D` based on texture target
    - insert `GpuFence` and associate it with the ring segment
  ☐ Maintain in-flight segments and retire in-order (poll fences; advance tail; release queue slots if needed).
  ☐ Ensure GL state is restored even when requests are invalid (pixel store reset; PBO unbind).


  Phase 5 - Full-Copy Fallback Path (Non-Persistent / Queue Full):
  Exit artifacts: StageCopy always deep-copies immediately even under backpressure or missing persistent support.
  ☐ Define an owned CPU buffer representation for fallback (`byte[]` or `IMemoryOwner<byte>` + metadata).
  ☐ If StageCopy cannot admit to the staging queue, deep-copy into owned buffer and enqueue to fallback.
  ☐ Render thread fallback execution:
    - stage owned buffer to triple-buffer PBO pool (or direct upload if explicitly allowed)
    - upload to texture, manage fences/pool reuse
  ☐ Track fallback reasons (queue full, ring full, not initialized, no persistent support, oversize, disabled).


  Phase 6 - Texture Target Coverage (All Types Up Front):
  Exit artifacts: StageCopy supports all expected targets and regions correctly.
  ☐ Validate/extend `TextureUploadTarget` helpers for:
    - 1D / 2D / 3D
    - 1D array / 2D array
    - cube faces / cube arrays
    - rectangle
  ☐ Validate the upload dispatcher chooses the correct TexSubImage variant for each target.
  ☐ Validate pixel store behavior for sub-rect uploads and 3D/array uploads (rowLength + imageHeight).


  Phase 7 - Producer Integration Defaults (DynamicTexture):
  Exit artifacts: DynamicTexture paths immediately copy to the streaming system by default.
  ☐ Update `DynamicTexture.UploadData(...)` and region overloads to use StageCopy by default.
  ☐ Preserve an explicit synchronous path for call sites that require immediate visibility.
  ☐ Update `DynamicTexture3D` helpers and other common producer paths (`Clear`, `CreateWithData`, etc.).
  ☐ Audit call sites for assumptions about immediate upload and update as needed.


  Phase 8 - Diagnostics, Tests, and Perf Verification:
  Exit artifacts: The refactor is measurable, stress-tested, and debuggable.
  ☐ Extend `TextureStreamingDiagnostics`:
    - queue depth, ring occupancy, in-flight fences
    - per-priority counters
    - fallback counts by reason
    - bytes/uploads per frame
  ☐ Add unit tests (no GL) for ring allocation and scheduler ordering.
  ☐ Add stress tests for multi-threaded StageCopy + simulated retire logic.
  ☐ Add a debug mode / instrumentation to validate uploads under load (RenderDoc-friendly labels).
  ☐ Tune defaults (ring size, queue capacity, budgets) and document recommended settings.


  Phase 9 - Future (Optional): Upgrade to Option A (Multi-Lane Priority):
  Exit artifacts: Priority lanes are pluggable without changing producer call sites.
  ☐ Implement `MultiLaneUploadQueue` behind `IUploadCommandQueue` (hi/med/low lanes).
  ☐ Add fairness policy (quota/round-robin + age promotion) and tests (avoid starvation).
  ☐ Add ring-space watermark/reservation so low-priority work cannot crowd out high-priority under load.
