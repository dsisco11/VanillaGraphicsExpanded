# UE5-Style Scoped Profiling Markers (EventSource) — Implementation Todo

Goal: Add a `using`/`IDisposable` scoped CPU profiling marker system (UE5-style) backed by .NET `EventSource`, with minimal overhead when disabled and optional integration points for existing profiler utilities.

---

## Phase 0 — Requirements + Alignment
- [ ] Confirm consumer tools: PerfView/ETW vs `dotnet-trace`/EventPipe vs both
- [ ] Decide naming + provider identity (provider name, keywords, levels)
- [ ] Decide if markers should support:
  - [ ] Nesting + per-thread stacks (optional)
  - [ ] Correlation IDs / Activity IDs (optional)
  - [ ] Categories/keywords (Render/WorldGen/IO/etc)

Docs:
- https://learn.microsoft.com/dotnet/api/system.diagnostics.tracing.eventsource
- https://learn.microsoft.com/dotnet/core/diagnostics/eventpipe
- https://learn.microsoft.com/dotnet/core/diagnostics/dotnet-trace

---

## Phase 1 — Workspace Discovery (Read-only)
- [x] Locate existing CPU profiling utilities in `vsapi` (e.g., frame profiler helpers)
- [x] Locate existing GPU marker system in `VanillaGraphicsExpanded` (e.g., baked profiler events/blocks)
- [x] Identify 2–4 high-value callsites to instrument first (render loop, mesh build, texture ops)
- [x] Check repo conventions for:
  - [x] Namespace/layout for utilities
  - [x] Logging patterns and build targets (.NET version)

Docs:
- PerfView overview: https://github.com/microsoft/perfview

---

## Phase 2 — Core API Design (Public Surface)
- [x] Define a minimal, ergonomic API:
  - [x] `Profiler.BeginScope(string name)` returns `ProfileScope : IDisposable`
  - [x] Optional overloads: `(string name, string category)` or `(string name, long id)`
  - [x] Provide no-op scope when disabled
- [x] Ensure API is allocation-free in the hot path:
  - [x] `ProfileScope` is `readonly struct`
  - [x] Fast-path gate: `EventSource.IsEnabled()`
  - [x] Avoid string interpolation or dynamic payload composition
- [x] Establish guidance for marker names (low cardinality)

Docs:
- EventSource best practices: https://learn.microsoft.com/dotnet/framework/performance/eventsource

---

## Phase 3 — EventSource Provider Implementation
- [x] Add a single provider `EventSource`:
  - [x] Stable provider name (e.g., `VintageStory.Profiling` or `VanillaGraphicsExpanded.Profiling`)
  - [x] Start/Stop event pair (begin/end)
  - [x] Payload fields (example): `Name`, `Category` (optional), `ThreadId` (optional), `Timestamp` (optional)
- [x] Define keywords and levels for filtering
- [ ] Add optional counters (only if useful):
  - [ ] `EventCounter`/`IncrementingEventCounter` (events/sec, active scopes, etc.)
- [ ] Add an `EventListener` sample for quick local verification

Docs:
- EventListener: https://learn.microsoft.com/dotnet/api/system.diagnostics.tracing.eventlistener
- EventCounters: https://learn.microsoft.com/dotnet/core/diagnostics/event-counters

---

## Phase 4 — Integration + Instrumentation
- [x] Integrate markers at selected hotspots:
  - [x] Render loop / mesh generation / texture processing (initial pass)
  - [ ] Any existing “frame profiler” hooks (bridge or coexist)
- [x] Validate nesting behavior and begin/end pairing under exceptions (scope disposal)
- [x] Ensure markers are safe in multi-threaded contexts

Docs:
- `dotnet-trace` providers and filtering: https://learn.microsoft.com/dotnet/core/diagnostics/dotnet-trace#collect-a-trace

---

## Phase 5 — Tests / Verification
- [x] Add a small unit/integration test (if existing test harness fits):
  - [x] Attach an `EventListener`, enable provider, emit a scoped marker, assert Start+Stop observed
  - [x] Verify payload fields (name/category) match
- [x] Add developer documentation for capturing traces:
  - [x] PerfView session notes (Windows)
  - [x] `dotnet-trace collect --providers ...`

Docs:
- `dotnet-trace` tutorial: https://learn.microsoft.com/dotnet/core/diagnostics/dotnet-trace

---

## Phase 6 — Performance + Polish
- [ ] Benchmark micro-overhead in disabled and enabled states
- [ ] Ensure minimal allocations in hot path (no boxing, no closures)
- [ ] Add guardrails for high-cardinality marker names (optional analyzer/guidelines)
- [ ] Confirm compatibility with the repo’s target frameworks and runtime

Docs:
- Perf considerations for tracing: https://learn.microsoft.com/dotnet/core/diagnostics/logging-tracing
